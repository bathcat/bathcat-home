---
title: "Potpourri"
description: "Temporary location for random stuff that needs to be deleted or moved."
status: 'Live'
flavor: 'Deck'
---

# Potpourri

---




## CSRF


---

### What's CSRF?
* Less of a concern with SPAs
* Common in [spear phishing](https://usa.kaspersky.com/resource-center/definitions/spear-phishing) technique
* <u>C</u>ross <u>S</u>ite <u>R</u>equest <u>F</u>orgery (CSRF)
* Logged-in user has a cookie, which passes along with every request
* If a user's page is compromised, the attacker can pretend to be the authenticated user

---

### Example: example.badactorstudio.com
* Real site: example.com
* **Attack**:
  - Email user link to example.badactorstudio.com
  - Browser sends form POST to real site with the user's authenticated cookie
  - Real site processes request and sends response


```html title='index.html'
<h1>You Are a Winner!</h1>
  <form action="http://example.com/api/account" method="post">
    <input type="hidden" name="Transaction" value="withdraw" />
    <input type="hidden" name="Amount" value="1000000" />
  <input type="submit" value="Click Me"/>
</form>
```

---

### Mitigations
1. Anti-Forgery Token
2. CORS policy
3. `SameSite` Cookie Attribute

---

### Mitigation #1: Anti-Forgery Token 
* Built-in to ASP.NET Core via [`AutoValidateAntiforgeryTokenAttribute`](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.autovalidateantiforgerytokenattribute?view=aspnetcore-3.1)
```csharp
public void ConfigureServices(IServiceCollection services){

    services.AddMvc(options=> options.filters.add(new AutoValidateAntiforgeryTokenAttribute());
}
```


---

### Solution
```html
<form action="/Home/Test" method="post">
    <input name="__RequestVerificationToken" type="hidden"   
           value="6fGBtLZmVBZ59oUad1Fr33BuPxANKY9q3Srr5y[...]" />    
    <input type="submit" value="Submit" />
</form>
```


---

### Mitigation #2: CORS policy
* Set a CORS policy on the API endpoint
* Works for:
  - XmlHttpRequest / Fetch API
* Ignored by:
  - Simple form POSTs

---

### Mitigation #3: `SameSite` Cookie Attribute
{/* TODO: Add example */}
* Set the `SameSite` attribute on the cookie


---




## JWT

---

### Bad Old Days
* Server-side session storage required
* Problems:
  - Scaling horizontally requires sticky sessions or shared session store
  - Cross-domain authentication difficult
  - Mobile apps and SPAs don't fit session model well
* Session ID in cookie has no information


---

### What's JWT?
* <u>J</u>SON <u>W</u>eb <u>T</u>oken
* Self-contained token with encoded claims
* Three parts: Header.Payload.Signature
* Signature verifies token hasn't been tampered with
* Stateless authentication
* [jwt.io](https://jwt.io)

---

### How does JWT work?

<div style="transform: scale(1.15); transform-origin: top center; margin-left: 15rem;"
>


```mermaid
sequenceDiagram
    participant Client
    participant API
    participant AuthServer
    
    Client->>AuthServer: POST /login (credentials)
    AuthServer-->>Client: Access Token + Refresh Token
    Client->>API: GET /data (Bearer Token)
    API-->>Client: Protected Data
    Note over Client,API: Access token expires
    Client->>AuthServer: POST /refresh (Refresh Token)
    AuthServer-->>Client: New Access Token
    Client->>API: GET /data (New Bearer Token)
    API-->>Client: Protected Data
```

</div>

---

### Jwt in .NET

```csharp title='ApplicationBuilderExtensions.cs'

public static IHostApplicationBuilder AddAuthentication(this IHostApplicationBuilder builder){
    var jwtSettings = builder.GetJwtSettings();

    builder.Services.AddAuthentication(options =>{
        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    })
    .AddJwtBearer(options =>{
        options.TokenValidationParameters = new TokenValidationParameters{
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(jwtSettings.Secret),
            ValidateIssuer = true,
            ValidIssuer = jwtSettings.Issuer,
            ValidateAudience = true,
            ValidAudience = jwtSettings.Audience,
        };
    });

    return builder;
}

```

---
### Angular Interceptor
{/* TODO: Simplify below for essentials */}
```typescript

export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const tokenStore = inject(TokenStoreService);
  const authService = inject(AuthService);
  const router = inject(Router);

  return next(req).pipe(
    catchError((error) => {
      if (error.status === 401 && !req.url.includes('/auth/')) {
        return authService.refreshToken().pipe(
          switchMap(() => {
            const newAccessToken = tokenStore.getAccessToken();
            if (newAccessToken) {
              req = req.clone({
                setHeaders: {
                  Authorization: `Bearer ${newAccessToken}`,
                },
              });
            }
            return next(req);
          }),
          catchError(() => {
            authService.signOut();
            router.navigate(['/signin']);
          })
        );
      }
      return throwError(() => error);
    })
  );
};
```



---


### Jwt Evaluated
* **Strengths**:
  - Self-contained, no database required
  - Supports federation and multiple clients
  - Configurable
* **Weaknesses**:
  - Tokens are stealable-- httponly cookies aren't

---



## Path Traversal

---


### What's Path Traversal?
* Aka *Directory Traversal*
* **Impact:** ranges from obnoxious vandalism to catastrophic data loss
* Attacker manipulates file paths using `../` sequences
* Accesses files outside intended directory

---

### The Root Problem
{/* TODO: Style tables in globals.scss */}
| Attack Type | Control Characters | Root Cause |
|------------:|-------------------|:------------|
| **SQL Injection** | `'`, `--`, `;` | Mixing data with SQL commands |
| **XSS** | `<script>`, `"`, `>` | Mixing data with HTML/JS |
| **Path Traversal** | `..`, `/`, `\` | Mixing data with filesystem paths |


<br/>
* **Common pattern**: Treating special input as ordinary strings + trusting users

* **Anti-pattern**: Primitive obsession (using `string` when you need something more specific)

---

### The Vulnerability
```csharp title='ImageUploadService.cs'
private async Task<ImageUploadResult> SaveImageCore(
    ReadOnlyMemory<byte> imageData,string fileName,string storageRoot){
        
    var extension = _path.GetExtension(fileName).ToLowerInvariant();
    if (!_options.AllowedExtensions.Contains(extension))
        return ImageUploadResult.FailureResult($"Extension not allowed");
    
    var mimeType = MimeTypes.GetMimeType(imageData.Span);
    if (mimeType is null)
        return ImageUploadResult.FailureResult("Invalid image");
    
    var physicalPath = _path.Combine(storageRoot, fileName);
    using (var fileStream = _fileStreamFactory.New(physicalPath, FileMode.Create)){
        await fileStream.WriteAsync(imageData);
    }
    
    return ImageUploadResult.SuccessResult(physicalPath, imageData.Length);
}
```
---

### The Exploit: Step by Step

| Step | Value | Result |
|------|-------|--------|
| **User provides** | `../../uploads/pilot-avatars/target.jpg` | Malicious filename |
| **storageRoot** | `/var/app/storage/user-123/` | Intended directory |
| **Path.Combine** | `/var/app/storage/user-123/../../uploads/pilot-avatars/target.jpg` | Combined path |
| **Normalized** | `/var/app/uploads/pilot-avatars/target.jpg` | Escaped intended directory! |
| **Impact** | üí• | Overwrites arbitrary file |

---

### Mitigation #1: Validation
* Check for path separator characters
* Reject any filename containing `/`, `\`, `..`
    
```csharp
if (fileName.Contains("..") || 
    fileName.Contains("/") || 
    fileName.Contains("\\")){
    return ImageUploadResult.FailureResult("Invalid filename");
}
```
---

### Mitigation #2: Type Safety
* Avoid primitive obsession
* Use value object or branded type for filenames
```csharp title='SafeFileName.cs'
public sealed class SafeFileName{
    public string Value { get; private set; }
        
    public static Result<SafeFileName> Create(string input){
        if (string.IsNullOrWhiteSpace(input) ||
            input.Contains("..") ||
            input.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0){
            return Result.Failure<SafeFileName>("Invalid filename");
        }
        return Result.Success(new SafeFileName{Value= input});
    }
    
    public override string ToString() => Value;
}
```

---

### Mitigation #3: Isolation
* Host user-uploaded content on separate origin
* Example: `api.example.com` vs `uploads.example.com`
* Limits blast radius if path traversal succeeds
* Also mitigates XSS in uploaded files


---



## Denial of Service

---

### What's [DoS](https://owasp.org/www-community/attacks/Denial_of_Service)?
* <u>D</u>enial <u>o</u>f <u>S</u>ervice attack
  - **DoS**: Single source attack
  - **DDoS**: <u>D</u>istributed attack from multiple sources
* **Goal**: Make service unavailable to legitimate users
* **Impact**: Ranges from temporary slowdown to complete shutdown

---

### Evolution of the Threat
* **Good news**: Ecosystem has improved dramatically
* **Then (2000s)**:
  - Easy to recruit botnet armies via XSS worms
  - Limited infrastructure protection
  - Browsers lacked modern security features
* **Now (2020s)**:
  - Browser security makes worm propagation harder
  - CDNs like [Cloudflare](https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/) provide edge protection
  - Cloud providers offer built-in DDoS mitigation


---

### [Mirai Botnet](https://en.wikipedia.org/wiki/Mirai_(malware)) (2016)
* Recruited 600,000+ IoT devices with default credentials
* Attacked Dyn DNS infrastructure
* Took down Twitter, Netflix, GitHub, Reddit, and more
* Combined failures:
  - IoT devices shipped with default passwords
  - No security updates for consumer devices
  - Critical DNS infrastructure vulnerability
* Peak traffic: 1.2 Tbps

---

### [GitHub Attack](https://www.wired.com/story/github-ddos-memcached/) (2018)
* Largest DDoS attack recorded at the time: 1.35 Tbps
* Memcached amplification attack
* GitHub mitigated in ~10 minutes using Akamai
* Attack mechanism:
  - Spoofed GitHub IPs in requests to memcached servers
  - Memcached servers amplified response 50,000x

---

### Mitigation #1: Rate Limiting
* Simple and effective for non-distributed attacks
* Built into ASP.NET Core
* Supports different policies for different endpoints

```csharp
public static IServiceCollection AddRateLimit(this IServiceCollection services)
=>  services.AddRateLimiter(options => {
        options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(httpContext =>
            RateLimitPartition.GetFixedWindowLimiter(
                partitionKey: httpContext.Request.Headers.Host.ToString(),
                factory: partition => new FixedWindowRateLimiterOptions{
                    AutoReplenishment = true,
                    PermitLimit = 1000,
                    QueueLimit = 0,
                    Window = TimeSpan.FromMinutes(1)
                }));
    });
```

---

### Dumb Example: Why Rate Limiting Works
```bash title='attack.sh'
while true; do
    curl https://example.com/pilots/
    sleep 0.01
done
```

**Why this is dumb:**
* Single IP address (trivial to block)
* Predictable pattern (easy to detect)
* Regular requests (rate limiter stops it immediately)
* Logged and traced (you will get caught)

---

### The Smarter Attack
* Rate limiting stops volume attacks
* **But**: Smart attackers target expensive operations
* Examples:
  - Exception-heavy endpoints
  - [Complex regex patterns (ReDoS)](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)
  - Wildcard database searches
  - Heavy computations
* **Historical example**: Node.js process crashes {/* TODO: Find source */}
  - Crash took ~1 second to restart
  - Continuous crashes = indefinite downtime

---

### Mitigation #2: Resource Protection
* Protect expensive operations
* **Strategies**:
  - Query complexity limits
  - Request timeouts
  - Circuit breakers
  - Async processing for heavy tasks
  - Pagination and result limits
* [Microsoft: Rate limiting middleware](https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit)
* [Polly: Resilience patterns](https://www.pollydocs.org/)

---

### [Defense in Depth](https://www.schneier.com/essays/archives/2003/11/beyond_fear_introduction.html)
* DoS attacks are more potent when combined with other vulnerabilities
* **Examples**:
  - Error disclosure reveals how to trigger exceptions
  - Resource exhaustion + session fixation
  - DoS during incident response masks other attacks
* **Principle**: No single mitigation is enough
* Monitor, alert, and respond to anomalies


---

## DTOs and Security

---

### Two Levels of Security

| Level | What You Protect | How You Protect It |
|-------|------------------|-------------------|
| **Entities** | Who can access resources | Authorization policies |
| **Fields** | What data is exposed | DTOs and mapping |

<br/>

* Defense in depth requires both
* Authorization without DTOs leaks sensitive data

---

### [What's a DTO?](https://martinfowler.com/bliki/LocalDTO.html)

* **<u>D</u>ata <u>T</u>ransfer <u>O</u>bject** - shapes data for wire transfer
* **Benefits**
  - Serialization control - Entities don't need JSON attributes
  - API versioning - Multiple DTOs can map to same entity
  - Contract stability - Entity changes don't break API
  - **Security** - Explicit about what's exposed

---

### [IDOR](https://owasp.org/www-community/attacks/Insecure_Direct_Object_References)

```csharp title="CustomerController.cs"
[Authorize(Roles = "Customer,Admin")]
[HttpGet("{id}")]
public async Task<Customer> GetCustomer(Guid id) 
    => await _db.Customers.FindAsync(id);

```
* **<u>I</u>nsecure <u>D</u>irect <u>O</u>bject <u>R</u>eference**
* Authentication works, but resource authorization is missing
* Any authenticated customer can access any other customer's data
* _Not catastrophic by itself_

---

### Information Disclosure

```csharp
public static async Task<Review> GetReview(IReviewService service, Guid id) 
    => await service.FindAsync(id);

public sealed class Review { // Review _entity_
    public Guid Id { get; set; }
    public Guid PilotId { get; set; }
    public Rating Rating { get; set; }
    public Guid CustomerId { get; set; }
}
```

* Returning entity directly leaks internal references
* Reviews are public; `CustomerId`s are not
* _Not catastrophic by itself_

---

### Chained Attack: Enumeration

**Step 1:** Harvest CustomerIds 
```bash
GET /reviews ‚Üí collect all CustomerId values
```

**Step 2:** Exploit IDOR to access customer data
```bash
GET /customers/{harvested-id} ‚Üí steal customer info
```

* Information disclosure + IDOR = devastating combination
* **Defense in depth failure:** two weaknesses compound

---

### [Mass Assignment](https://owasp.org/www-community/vulnerabilities/Mass_Assignment) (aka Over-posting)

```csharp title="ReviewEndpoint.cs"
public static async Task<Created> CreateReview(
    IReviewService service, ICurrentUser current, Review request) {
    
    if(request.CustomerId == Guid.Empty){
        request.CustomerId = current.CustomerId;
    }
    var id = await service.CreateReview(request);
    return TypedResults.Created($"/reviews/{id}");
}
```

* Binding directly to entity accepts all properties from user input
* Attacker supplies `CustomerId` to impersonate others
* **Failure:** No boundary protection between wire and entity

---

### The Fix: Admin-Specific DTO

```csharp title="ReviewEndpoint.cs"
public static async Task<Created> CreateReview(
    IReviewService service, CreateReviewRequest request) {
    var id = await service.CreateReview(
      request.PilotId, 
      request.Rating, 
      current.CustomerId
    );
    return TypedResults.Created($"/reviews/{id}");
}
```
```csharp title="CreateReviewRequest.cs"
public record CreateReviewRequest(
  Guid PilotId, 
  Rating Rating, 
  Guid CustomerId
);
```
---

### The Fix (II): Customer-Specific DTO
```csharp title="ReviewEndpoint.cs"
public static async Task<Created> CreateMyReview(
    IReviewService service, ICurrentUser current, CreateMyReviewRequest request
    ) {
    var id = await service.CreateReview(
      request.PilotId, 
      request.Rating, 
      current.CustomerId
    );
    return TypedResults.Created($"/my-reviews/{id}");
}
```

```csharp title="CreateMyReviewRequest.cs"
public record CreateMyReviewRequest(Guid PilotId, Rating Rating);
```

---

### Mapping Tools

| Approach | Examples | AOT? | Pros | Cons |
|----------|----------|----------------|------|------|
| **Reflection-based** | AutoMapper, Mapster | ‚ùå | Less boilerplate | Runtime overhead, magic |
| **Source generation** | Mapperly, MapsterSourceGen | ‚úÖ | AOT | Setup complexity |
| **Manual mapping** | Custom classes | ‚úÖ | Full control, compiler help | More code |

---

### Manual Mapper Class

```csharp title="IMapper.cs"
public interface IMapper<TSource, TDestination> {
    TDestination Map(TSource source);
}
```
```csharp
public class ReviewMapper : IMapper<Review, ReviewDto> {
    public ReviewDto Map(Review source) 
        => new ReviewDto {
            Id = source.Id,
            PilotId = source.PilotId,
            Rating = source.Rating,
            Notes = source.Notes,
            CreatedAt = source.CreatedAt
        };   
}

public record ReviewDto(Guid Id, Guid PilotId, Rating Rating, string Notes, DateTime CreatedAt);
```

---

### Using the Mapper

```csharp title='ReviewEndpoints.cs' {7}
public async Task<Ok<ReviewDto>> GetReview(
    IReviewService service, 
    IMapper<Review, ReviewDto> mapper, 
    Guid id) {
    
    var review = await service.GetReviewAsync(id);
    return TypedResults.Ok(mapper.Map(review));
}
```

* Entity stays internal with all fields including `CustomerId`
* DTO exposes only what public API should return
* Explicit mapping with compiler enforcement

---

### Manual Mapping: Why It Works

* Compiler enforces all `required` properties are set
* Easy to write with AI assistance
* Explicit and auditable
* No magic or runtime reflection
* AOT-compatible

---



## Secrets Management

---

### What Are Secrets?

* **Secrets**: Long-lived credentials with elevated privileges, not user-specific
* Examples: 
  - JWT signing keys, 
  - Database connection strings, 
  - API keys
* [Uber breach (2016)](https://www.ftc.gov/news-events/news/press-releases/2018/09/uber-pays-148-million-settle-data-breach-coverup)
  - AWS credentials in private GitHub repo
  - 57 million records stolen

---

### Client-Side Reality Check

* **Web browsers**: Nothing is secret (DevTools exposes everything)
* **Mobile apps**: Reverse engineering extracts embedded keys
* **Solution**: Design assuming client secrets will be compromised
  - Use short-lived tokens, not long-lived API keys
  - Backend validates all permissions
  - Client never makes authorization decisions

---

### The Landscape

| Approach | Developer Experience | Security | Typical Use |
|----------|:-------------------:|:--------:|:------------|
| **appsettings.json** | ‚≠ê‚≠ê‚≠ê | ‚ùå | Local dev only |
| **Environment variables** | ‚≠ê‚≠ê | ‚ö†Ô∏è | Containers, CI/CD |
| **Azure Key Vault** | ‚≠ê | ‚úÖ | Production |

<br/>

* Trade-off is real: convenience vs. protection
* No perfect solution; choose based on environment and risk



---

### Approach #1: Configuration Files

```csharp
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=prod;Database=app;User=sa;Password=SuperSecret123"
  },
  "JwtSettings": {
    "Secret": "my-super-secret-key-that-should-not-be-here"
  }
}
```

**Vulnerabilities:**
* Path traversal attacks can expose files
* Accidentally committed to source control
* Visible in deployed artifacts and backups

---

### Approach #2: Environment Variables

**Strengths:**
* Not stored in source control
* Standard across platforms (Docker, Kubernetes, Azure, AWS)
* Easy to rotate without code changes

**Weaknesses:**
* Unencrypted in memory
* Visible in process listings (`ps aux`, Task Manager)
* Often logged in deployment pipelines
* Insider threat: anyone with server access can read them

---

### Approach #3: Secrets Manager Pattern

```csharp
var connectionString = builder.Configuration["ConnectionStrings:DefaultConnection"];
var jwtSecret = builder.Configuration["JwtSettings:Secret"];
```

**Key insight:** App code is agnostic to storage implementation

* `IConfiguration` abstraction decouples retrieval from storage
* Dev environment: dotnet user-secrets (encrypted local file)
* Production: Azure Key Vault (centralized cloud service)
* Same API, different backing store per environment

---

### [Local Dev: `dotnet user-secrets`](https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets)

```bash
dotnet user-secrets init
dotnet user-secrets set "ConnectionStrings:DefaultConnection" "Server=localhost;..."
dotnet user-secrets set "JwtSettings:Secret" "dev-only-key-12345"
dotnet user-secrets list
```

**How it works:**
* Stored outside project directory (never in source control)
* Encrypted on local machine at `%APPDATA%\Microsoft\UserSecrets`
* Per-project isolation via unique ID in `.csproj`

---

### Production: Azure Key Vault

```csharp
builder.Configuration.AddAzureKeyVault(
    new Uri($"https://{keyVaultName}.vault.azure.net/"),
    new DefaultAzureCredential()
);
```

**Strengths:**
* Centralized, encrypted storage with audit trails
* Fine-grained access policies per secret
* Rotation without redeployment

**Weaknesses:**
* Developer onboarding friction (every dev needs access configured)
* External dependency (network latency, availability)
* Cost scales with access frequency

---

### Common Vulnerabilities: Privileged Access

* **All approaches** remain vulnerable to privileged insiders:
  - Ops/DevOps engineers with deployment access
  - Cloud provider support staff
  - Database administrators with production access
  - Platform engineers managing infrastructure

**Reality:**
* These roles need access to do their jobs
* Trust is unavoidable, but audit trails help
* Principle of least privilege reduces exposure

---

### Common Vulnerabilities: Inadvertent Exposure

* Third-party services with broad access:
  - Log aggregators (Datadog, Splunk) ingesting secrets from logs
  - APM tools (New Relic, Application Insights) capturing request details
  - CI/CD platforms storing secrets in build logs
  - Support ticket systems where devs paste error messages

**The problem:**
* Each integration multiplies attack surface
* One misconfigured integration bypasses all your careful work
* Example: `logger.Info($"Using connection: {connectionString}")`

---

### Architecture: Limiting Blast Radius

* **Principle**: Each service gets only what it needs
* **Example #1**: 
  - Token-issuing service: private signing key
  - Resource APIs: public verification key only
* **Example #2**:
  - Each business service: connection string to its own database
  - No service has credentials for all databases
* [Principle of least privilege](https://learn.microsoft.com/en-us/azure/security/fundamentals/identity-management-best-practices#lower-exposure-of-privileged-accounts) at the service level
* Works great for microservices, doesn't help a monolith

