---
title: "Tokens"
description: "OAuth, JWT, and token-based authentication patterns for Angular and .NET applications. Learn delegation, federation, and session security."
status: 'Live'
flavor: 'Deck'
---

# Tokens

---

### Goals
By the end of this deck, you should be able to answer--
1. What's the difference between **primary** and **session** authentication?
2. What's the difference between **access tokens** and **refresh tokens**?
3. Which token storage location has the highest **XSS risk**?


---

### Roadmap
1. Overview
2. OAuth
3. JWT & Refresh Tokens

---

## Overview

---

### The Password Problem
* Traditional auth: you store hashed passwords
* Problems:
  - Getting the implementation right
  - Liability for a breach
  - Regulatory compliance
* ***It would be nice*** if my app could rely on someone else to handle authentication
---

### Primary vs Session Authentication

* **Primary authentication:** User presents credentials (password, biometric, hardware key)
* **Session authentication:** User proves they already authenticated
* Primary auth happens once, session auth happens every request
* Tokens and cookies are session authentication mechanisms
* OAuth handles primary auth, your app handles session tokens

---

### The Attack Vector Shift

* Traditional apps: attacker targets password database and login forms
* OAuth-based apps: attacker targets session tokens instead
* [Credential phishing](https://owasp.org/www-community/attacks/Credential_stuffing) â†’ token hijacking
* Token theft through [XSS](https://owasp.org/www-community/attacks/xss/), network interception, or malware
* This shift motivates refresh tokens, rotation, and secure storage

---

### What's a Security Token?

* Proof you've authenticated, used for subsequent requests
* Two flavors:
  - **Self-contained** (like a driver's license): carries information with it
  - **Opaque** (like a credit card number): just a reference, server must look up details
* Self-contained tokens enable federation, opaque tokens enable revocation
* Choice depends on your needs

---

### Federation & Microservices

* Single auth service issues cryptographically signed tokens
* All downstream services validate signature independently
* No shared session store, no database calls for every auth check
* Business logic services never implement authentication
* Huge win at enterprise scale with many services
* **Reality check:** Overkill for simple apps with one API

[Microsoft: Federated Identity](https://learn.microsoft.com/en-us/azure/architecture/patterns/federated-identity)

---

### Token-Based Architecture

<div style="transform: scale(1.45); transform-origin: top center; margin-left: 10em;">

```mermaid
sequenceDiagram
    participant App as Your App
    participant Identity as Identity Service
    participant API as Other Services
    
    App->>Identity: Present credentials (primary auth)
    Identity->>App: Issue signed token
    App->>API: Request + token (session auth)
    API->>API: Validate signature
    API->>App: Protected resource
```

</div>


---
### Notes

* Identity service handles primary authentication
* Other services trust the token, never see credentials
* Clear separation: authentication vs authorization
* Works with any provider (Google, internal, etc.)

---

## OAuth



---

### What's [OAuth 2.0](https://oauth.net/2/)?
* Delegated authorization framework
* Third-party identity providers handle credentials
* Your app receives tokens, never passwords
* Key advantage: eliminates password management burden
* Enables federation across services

---

### OAuth/OpenID Timeline

```mermaid
timeline
    2007 : OAuth 1.0 specification
    2010 : OAuth 1.0a (security fixes)
    2012 : OAuth 2.0 (RFC 6749)
    2014 : OpenID Connect 1.0
         : PKCE extension (RFC 7636)
    2019 : OAuth 2.0 Security Best Practices
    2020 : OAuth 2.1 draft consolidation
    2023 : Google Identity Services mainstream adoption
```


---

### OAuth Use Cases

* **Authentication offloading (95% of cases):**
  - United Airlines doesn't want your password
  - United just wants Google to confirm "this is really bob@gmail.com"
  - No authorization needed, just identity
* **Actual authorization (niche):**
  - App needs to access user's Google Drive folders
  - App posts tweets on user's behalf
  - Requires delegated permissions

---

### OAuth Complaints
{/* TODO: Add these links:
- [Still hard in 2025](https://nango.dev/blog/why-is-oauth-still-hard) */}
* **Super complicated.** 17 [RFCs](https://oauth.net/specs/) for OAuth 2.0 alone.
* **Implementations vary.** From the [spec](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-30#section-1.8): "this specification is likely to produce a wide range of non-interoperable implementations."
* **Evolving best practices.** e.g. OAuth 2.0 â†’ 2.1, new PKCE requirements
* **Trade-off:** 
  - __Possibly__ better than rolling your own password system
  - __Certainly__ better than keeping passwords in your database

---

### [Former Lead Author](https://gist.github.com/nckroy/dd2d4dfc86f7d13045ad715377b6a48f)
<figure class='bc-framed-image bc-figure-float' style='width:25%;height:auto;'>
![Borges](./assets/Borges_1921.jpg)
</figure>


> OAuth 2.0 is a bad protocol. WS-* bad. It is bad enough that I no longer want to be associated with it. 
> It is the biggest professional disappointment of my career.

Eran Hammer, former lead author of OAuth 2.0

---

### OAuth: Two Patterns

| Traditional Redirect | Modern JavaScript |
|---------------------|-------------------|
| Full page redirect to provider | Popup or embedded UI |
| Authorization code in URL | Token delivered via JavaScript |
| Backend exchanges code | SPA receives token directly |
| Better security (backend secret) | Better UX (no page reload) |

* **Reality:** You'll use provider's library (Google Identity Services, Auth0 SDK, etc.)
* **Both patterns** follow same high-level flow
* **Key point:** OAuth gets you a token, your backend validates it


---

### [Google Identity Services](https://developers.google.com/identity/gsi/web)
* Modern alternative to traditional redirect flows
* One Tap sign-in with minimal friction
* Popup-based authorization (better UX)
* Still OAuth 2.0 + OpenID Connect underneath
* Similar patterns: Microsoft Identity Platform, Auth0 Universal Login

---

### SPA Authentication Pattern

<div style="transform: scale(1.35); transform-origin: top center; margin-left: 8em;">

```mermaid
sequenceDiagram
    participant User
    participant SPA as Your SPA
    participant Backend as Your Backend
    participant Google
    
    User->>Google: Sign in via provider library
    Google->>SPA: Access token (JWT)
    SPA->>Backend: POST /auth/google (token)
    Backend->>Backend: Validate token signature
    Backend->>SPA: Set httpOnly cookie
    SPA->>Backend: Subsequent requests (cookie)
    Backend->>SPA: Protected data
```

</div>

---

### Notes
* Provider handles primary auth, your backend handles session
* Backend validates JWT signature (no call to Google needed)
* httpOnly cookie protects against XSS

---

### .NET Backend: Google OAuth

```csharp title='Program.cs'
builder.Services
    .AddAuthentication(options => {
        options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
        options.DefaultChallengeScheme = GoogleDefaults.AuthenticationScheme;
    })
    .AddCookie()
    .AddGoogle(options => {
        options.ClientId = builder.Configuration["Authentication:Google:ClientId"];
        options.ClientSecret = builder.Configuration["Authentication:Google:ClientSecret"];
        options.Scope.Add("email");
        options.Scope.Add("profile");
    });
```

[Microsoft Docs: Google authentication](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social/google-logins)

---

### Angular Frontend: OAuth Setup

```typescript title='app.config.ts'
import { AuthConfig } from 'angular-oauth2-oidc';

export const authConfig: AuthConfig = {
  issuer: 'https://accounts.google.com',
  redirectUri: window.location.origin,
  clientId: 'YOUR_CLIENT_ID.apps.googleusercontent.com',
  scope: 'openid profile email',
  responseType: 'code',
  showDebugInformation: true,
  strictDiscoveryDocumentValidation: false,
};
```

[angular-oauth2-oidc documentation](https://github.com/manfredsteyer/angular-oauth2-oidc)

---

### Token Exchange Pattern

* **Step 1:** SPA completes OAuth, receives provider's token (Google, Microsoft, etc.)
* **Step 2:** SPA sends provider token to your backend
* **Step 3:** Backend validates provider token (checks signature + claims)
* **Step 4:** Backend issues your own JWT + refresh token pair
* **Step 5:** Backend sets httpOnly cookies (or returns tokens for mobile)
* **Why?** Decouple from provider, add custom claims, unified token format across providers

---




## JWT & Refresh Tokens

---

### What's [JWT](https://jwt.io)?
* <u>J</u>SON <u>W</u>eb <u>T</u>oken
* Self-contained token with encoded claims
* Signature verifies token hasn't been tampered with
* Enables stateless session authentication

---

### [JWT Structure](https://datatracker.ietf.org/doc/html/rfc7519)  

| Part | Content | Purpose |
|------|---------|---------|
| **Header** | Algorithm and token type | Describes how to validate |
| **Payload** | Claims (user ID, roles, expiration) | The actual data |
| **Signature** | HMAC or RSA signature | Proves authenticity |

* Base64-encoded and concatenated: `eyJhbGc...eyJzdWI...SflKxw`

---

### JWT: The Driver's License

* **Like a driver's license:**
  - Issued by trusted authority (state/auth server)
  - Contains information (name, DOB, photo / userId, roles, expiration)
  - Bouncer validates authenticity without calling DMV
* **Unlike a credit card:**
  - Credit card is just a number (opaque token)
  - POS system must call issuer to check balance
  - Enables revocation but requires lookup

---

### Where Do I Get a Token?
* On primary authentication
* On refresh
* In both cases, tokens come in pairs
  - Access token (JWT)
  - Refresh token (opaque string)

---

### Why Two Tokens?

* **Security trade-off:** Short-lived access tokens limit blast radius
* Stolen access token expires quickly (minutes/hours)
* Refresh token compromise is detectable and revocable
* User doesn't re-authenticate constantly
* Refresh tokens stored as hashes (like passwords) in database
* Enables logout: revoke refresh token, access token expires naturally

---

### Refresh Token Anatomy

* Opaque tokens: cryptographically random strings
* Not JWTs (not self-contained, not readable)
* Stored as hashes in database with user association
* **Why opaque?** Enables revocation, rotation, and invalidation
* Server looks up hash, validates, issues new access token
* Think of them like session IDs with longer lifespan

---

### Token Refresh Flow

```mermaid
sequenceDiagram
    participant Client
    participant API
    participant AuthServer
    
    Client->>AuthServer: POST /login (credentials)
    AuthServer-->>Client: Access Token + Refresh Token
    Client->>API: GET /data (Bearer Access Token)
    API-->>Client: Protected Data
    Note over Client,API: Access token expires
    Client->>AuthServer: POST /refresh (Refresh Token)
    AuthServer->>AuthServer: Validate hash in database
    AuthServer-->>Client: New Access Token
    Client->>API: GET /data (New Bearer Token)
    API-->>Client: Protected Data
```


---

### Request Anatomy (I)
```http {1,5} title='Request with Access Token'
GET /api/v1/deliveries/my-deliveries?skip=0&take=4 HTTP/1.1
Accept: application/json, text/plain, */*
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: en-US,en;q=0.9
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Connection: keep-alive
```

* Response:
  - Either **200 OK** + Content
  - **Or** **401 Unauthorized** - Access token expired (probably)

---

### Request Anatomy (II)
```http {1,9} title='Request with Refresh Token'
POST /api/v1/auth/refresh HTTP/1.1
Accept: application/json, text/plain, */*
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: en-US,en;q=0.9
Connection: keep-alive
Content-Length: 62
Content-Type: application/json

{"refreshToken": "8EE8wwVZYkcHaItS4_ZHS5p2bLObAjQdkUXBhMyAQY8"}
```

```json title='Response with New Access Token'
{
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVC...",
    "refreshToken": "O2ThQ6aTSxN6PUbaFyFT9bn1xqZoR-MrSpNpWLBMdxw",
}
```
---

### Access Tokens vs Refresh Tokens

| | Access Token | Refresh Token |
|---:|:--------------|:---------------|
| **Lifetime** | Minutes to hours | Days to months |
| **Format** | Usually JWT (self-contained) | Opaque string |
| **Usage** | Every API request | Token refresh only |
| **API Storage** | Stateless | Backend database |
| **Revocation** | Difficult (stateless) | Easy (database lookup) |


---



### JWT in .NET

```csharp title='ApplicationBuilderExtensions.cs'

public static IHostApplicationBuilder AddAuthentication(this IHostApplicationBuilder builder){
    var jwtSettings = builder.GetJwtSettings();

    builder.Services.AddAuthentication(options =>{
        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    })
    .AddJwtBearer(options =>{
        options.TokenValidationParameters = new TokenValidationParameters{
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(jwtSettings.Secret),
            ValidateIssuer = true,
            ValidIssuer = jwtSettings.Issuer,
            ValidateAudience = true,
            ValidAudience = jwtSettings.Audience,
        };
    });

    return builder;
}

```

---

### Angular Interceptor

```typescript
export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const router = inject(Router);

  return next(req).pipe(
    catchError((error) => {
      if (error.status !== 401) {
        return throwError(() => error);
      }
      return authService.refreshToken().pipe(
        //Try again with the new token
        switchMap(() => next(req)),
        //Give up and sign out.
        catchError(() => {
          authService.signOut();
          router.navigate(['/signin']);
          return throwError(() => error);
        })
      );
    })
  );
};
```

---

### Token Storage (Client-Side)

| Location | Security | Persistence | XSS Risk | CSRF Risk |
|------------------:|:-----------|:------------|:---------|:----------|
| **Memory only** | ðŸŸ¢ High | Session only | ðŸŸ¢ Low | ðŸŸ¢ Low |
| **localStorage** | ðŸ”´ Low | Persistent | ðŸ”´ High | ðŸŸ¢ Low |
| **sessionStorage** | ðŸŸ¡ Medium | Tab-scoped | ðŸ”´ High | ðŸŸ¢ Low |
| **HttpOnly Cookie** | ðŸŸ¢ High | Persistent | ðŸŸ¢ Low | ðŸŸ¡ Medium |

---

### Hybrid Token Strategy

* **Web clients:** HttpOnly cookies protect against [XSS token theft](https://owasp.org/www-community/attacks/xss/)
* **Native clients:** Standard Bearer tokens (cookies don't work well)
* **Challenge:** Supporting both from same API endpoints
* **Solution:** Middleware transparently converts cookies â†’ Bearer header
* Downstream authentication sees only Bearer tokens (consistent)

---

### Cookie-to-JWT Middleware

```csharp title='CookieToJwtMiddleware.cs'
public class CookieToJwtMiddleware {
    private readonly RequestDelegate _next;

    public async Task InvokeAsync(HttpContext context) {
        if (!context.Request.Headers.ContainsKey("Authorization") 
            && Cookies.HasAccessToken(context)) {
            var accessToken = Cookies.GetAccessToken(context);
            context.Request.Headers.Append("Authorization", $"Bearer {accessToken}");
        }
        await _next(context);
    }
}
```

Register before `UseAuthentication()` in middleware pipeline

---

### JWT Evaluated
* **Strengths**:
  - Self-contained, no database lookup required
  - Supports federation and multiple services
  - Configurable claims and expiration
  - Scales horizontally without sticky sessions
* **Weaknesses**:
  - Difficult to revoke before expiration
  - Tokens are stealable if not using httpOnly cookies
  - Larger size than opaque tokens

---

## Fin

---

### Recap
1. What's the difference between **primary** and **session** authentication?
2. What's the difference between **access tokens** and **refresh tokens**?
3. Which token storage location has the highest **XSS risk**?

