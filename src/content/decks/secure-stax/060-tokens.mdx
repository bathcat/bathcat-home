---
title: "Tokens"
description: "OAuth, JWT, and token-based authentication patterns for Angular and .NET applications. Learn delegation, federation, and session security."
status: 'Live'
flavor: 'Deck'
---

# Tokens

---

### Goals
By the end of this deck, you should be able to answer--
1. What's the difference between **primary** and **session** authentication?
2. What's the difference between **access tokens** and **refresh tokens**?
3. Which token storage location has the highest **XSS risk**?


---

### Roadmap
1. Overview
2. OAuth
3. JWT & Refresh Tokens

---

## Overview

---

### The Password Problem
* Traditional auth: you store hashed passwords
* Regulatory compliance burden (GDPR, SOC2, PCI)
* Breach liability and notification requirements
* [Password reuse](https://owasp.org/www-community/attacks/Credential_stuffing) across sites amplifies damage
* OAuth delegates identity to Google, Microsoft, Auth0, etc.

---

### Primary vs Session Authentication

* **Primary authentication:** User presents credentials (password, biometric, hardware key)
* **Session authentication:** User proves they already authenticated
* Primary auth happens once, session auth happens every request
* Tokens and cookies are session authentication mechanisms
* OAuth handles primary auth, your app handles session tokens

---

### The Attack Vector Shift

* Traditional apps: attacker targets password database and login forms
* OAuth-based apps: attacker targets session tokens instead
* [Credential phishing](https://owasp.org/www-community/attacks/Credential_stuffing) â†’ token hijacking
* Token theft through [XSS](https://owasp.org/www-community/attacks/xss/), network interception, or malware
* This shift motivates refresh tokens, rotation, and secure storage

---

### Federation & Microservices

* Single auth service issues cryptographically signed tokens
* All downstream services validate signature independently
* No shared session store, no database calls for every auth check
* Business logic services never implement authentication
* Huge win at enterprise scale with many services
* **Reality check:** Overkill for simple apps with one API

[Microsoft: Federated Identity](https://learn.microsoft.com/en-us/azure/architecture/patterns/federated-identity)

---

### Token-Based Architecture
<div style="transform: scale(1.55); transform-origin: top center; margin-left: 10em;">
```mermaid
sequenceDiagram
    participant User
    participant App as Your App
    participant OAuth as OAuth Provider
    participant API as Microservices
    
    User->>OAuth: Present credentials (primary auth)
    OAuth->>App: Issue signed token
    App->>API: Request + token (session auth)
    API->>API: Validate signature
    API->>App: Protected resource
```
</div>
---

## OAuth



---

### What's [OAuth 2.0](https://oauth.net/2/)?
* Delegated authorization framework
* Third-party identity providers handle credentials
* Your app receives tokens, never passwords
* Key advantage: eliminates password management burden
* Enables federation across services

---

### OAuth/OpenID Timeline

```mermaid
timeline
    2007 : OAuth 1.0 specification
    2010 : OAuth 1.0a (security fixes)
    2012 : OAuth 2.0 (RFC 6749)
    2014 : OpenID Connect 1.0
         : PKCE extension (RFC 7636)
    2019 : OAuth 2.0 Security Best Practices
    2020 : OAuth 2.1 draft consolidation
    2023 : Google Identity Services mainstream adoption
```

---

### Authentication vs Authorization
* **Pedantic view:** [OAuth is authorization](https://oauth.net/articles/authentication/), not authentication
* OAuth tells you what a user **can do**, not **who they are**
* That's technically [OpenID Connect](https://openid.net/connect/)'s job (built on OAuth)
* **Reality:** OAuth + OIDC = de facto authentication standard
* Most implementations use both together

---

### OAuth Complaints

* You don't need cryptography expertise to understand bcrypt + salt + pepper
* But OAuth? That's a **trivia contest** across [many RFCs](https://oauth.net/specs/)
* Google, Microsoft, Twitter implement OAuth differently
* Constantly evolving best practices (OAuth 2.0 â†’ 2.1, new PKCE requirements)
* Easy to misconfigure securely
* **Trade-off:** Still better than rolling your own password system

---

### OAuth 2.0 Authorization Code Flow

<div style="transform: scale(1.25); transform-origin: top center; margin-left: 8em;">

```mermaid
sequenceDiagram
    participant User
    participant SPA as Your SPA
    participant Provider as Google/Auth0
    participant API as Your API
    
    User->>SPA: Click "Sign in with Google"
    SPA->>Provider: Redirect to authorization endpoint
    Provider->>User: Show consent screen
    User->>Provider: Grant permission
    Provider->>SPA: Redirect with authorization code
    SPA->>Provider: Exchange code for tokens
    Provider->>SPA: Access token + ID token
    SPA->>API: Request with Bearer token
    API->>SPA: Protected resource
```
</div>

---

### Authorization Code Flow: Step by Step

| Step | Description |
|------|-------------|
| **1. Authorization Request** | Redirect to provider with client_id, redirect_uri, scope |
| **2. User Consent** | Provider authenticates user and shows permissions |
| **3. Authorization Code** | Provider redirects back with short-lived code |
| **4. Token Exchange** | Backend exchanges code for tokens (client_secret required) |
| **5. Access Resources** | Use access token in Authorization header |

[OAuth 2.0 Authorization Framework (RFC 6749)](https://datatracker.ietf.org/doc/html/rfc6749)

---

### Modern OAuth: [PKCE](https://datatracker.ietf.org/doc/html/rfc7636)
* **P**roof **K**ey for **C**ode **E**xchange
* Prevents authorization code interception attacks
* Browser generates code_verifier (random string)
* Sends code_challenge (hash of verifier) with auth request
* Provider validates verifier matches challenge on token exchange
* **Required** for SPAs and mobile apps
* [Recommended for all OAuth clients](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)

---

### [Google Identity Services](https://developers.google.com/identity/gsi/web)
* Modern alternative to traditional redirect flows
* One Tap sign-in with minimal friction
* Popup-based authorization (better UX)
* Still OAuth 2.0 + OpenID Connect underneath
* Similar patterns: Microsoft Identity Platform, Auth0 Universal Login

---

### .NET Backend: Google OAuth

```csharp title='Program.cs'
builder.Services
    .AddAuthentication(options => {
        options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
        options.DefaultChallengeScheme = GoogleDefaults.AuthenticationScheme;
    })
    .AddCookie()
    .AddGoogle(options => {
        options.ClientId = builder.Configuration["Authentication:Google:ClientId"];
        options.ClientSecret = builder.Configuration["Authentication:Google:ClientSecret"];
        options.Scope.Add("email");
        options.Scope.Add("profile");
    });
```

[Microsoft Docs: Google authentication](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social/google-logins)

---

### Angular Frontend: OAuth Setup

```typescript title='app.config.ts'
import { AuthConfig } from 'angular-oauth2-oidc';

export const authConfig: AuthConfig = {
  issuer: 'https://accounts.google.com',
  redirectUri: window.location.origin,
  clientId: 'YOUR_CLIENT_ID.apps.googleusercontent.com',
  scope: 'openid profile email',
  responseType: 'code',
  showDebugInformation: true,
  strictDiscoveryDocumentValidation: false,
};
```

[angular-oauth2-oidc documentation](https://github.com/manfredsteyer/angular-oauth2-oidc)

---

### Token Exchange Pattern

* SPA completes OAuth flow, receives Google's ID token
* SPA sends Google token to **your API's** `/auth/google` endpoint
* Your API validates Google token and issues **your own** JWT pair
* SPA uses your tokens for all subsequent requests
* **Why?** Decouple from provider, add custom claims, control expiration
* Enables multiple auth methods (Google, Microsoft, local) with consistent tokens

[Auth0: Token Exchange](https://auth0.com/docs/secure/tokens/token-exchange) | [OAuth 2.0 Token Exchange (RFC 8693)](https://datatracker.ietf.org/doc/html/rfc8693)

---

### OAuth Security Gotchas

* Validate redirect_uri against whitelist (prevent [open redirects](https://cwe.mitre.org/data/definitions/601.html))
* Always use **state** parameter (CSRF protection)
* Validate JWT signatures with provider's public keys
* Check token expiration and audience claims
* **HTTPS only** in production
* Avoid storing tokens in localStorage if possible

[OWASP OAuth 2.0 Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OAuth2_Cheat_Sheet.html)

---

## JWT & Refresh Tokens

---

### What's [JWT](https://jwt.io)?
* <u>J</u>SON <u>W</u>eb <u>T</u>oken
* Self-contained token with encoded claims
* Signature verifies token hasn't been tampered with
* Enables stateless session authentication

---

### [JWT Structure](https://datatracker.ietf.org/doc/html/rfc7519)  

| Part | Content | Purpose |
|------|---------|---------|
| **Header** | Algorithm and token type | Describes how to validate |
| **Payload** | Claims (user ID, roles, expiration) | The actual data |
| **Signature** | HMAC or RSA signature | Proves authenticity |

* Base64-encoded and concatenated: `eyJhbGc...eyJzdWI...SflKxw`

---

### Where Do I Get a Token?
* On primary authentication
* On refresh
* In both cases, tokens come in pairs
  - Access token (JWT)
  - Refresh token (opaque string)

---

### Why Both Tokens?

* **Security trade-off:** Short-lived access tokens limit blast radius
* Stolen access token expires quickly (minutes/hours)
* Refresh token compromise is detectable and revocable
* User doesn't re-authenticate constantly
* Refresh tokens stored as hashes (like passwords) in database
* Enables logout: revoke refresh token, access token expires naturally

---

### Refresh Token Anatomy

* Opaque tokens: cryptographically random strings
* Not JWTs (not self-contained, not readable)
* Stored as hashes in database with user association
* **Why opaque?** Enables revocation, rotation, and invalidation
* Server looks up hash, validates, issues new access token
* Think of them like session IDs with longer lifespan

---

### Token Refresh Flow

```mermaid
sequenceDiagram
    participant Client
    participant API
    participant AuthServer
    
    Client->>AuthServer: POST /login (credentials)
    AuthServer-->>Client: Access Token + Refresh Token
    Client->>API: GET /data (Bearer Access Token)
    API-->>Client: Protected Data
    Note over Client,API: Access token expires
    Client->>AuthServer: POST /refresh (Refresh Token)
    AuthServer->>AuthServer: Validate hash in database
    AuthServer-->>Client: New Access Token
    Client->>API: GET /data (New Bearer Token)
    API-->>Client: Protected Data
```


---

### Request Anatomy (I)
```http {5} title='Request with Access Token'
GET /api/v1/deliveries/my-deliveries?skip=0&take=4 HTTP/1.1
Accept: application/json, text/plain, */*
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: en-US,en;q=0.9
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Connection: keep-alive
```

* Response:
  - Either **200 OK** + Content
  - **Or** **401 Unauthorized** - Access token expired (probably)

---

### Request Anatomy (II)
```http {9} title='Request with Refresh Token'
POST /api/v1/auth/refresh HTTP/1.1
Accept: application/json, text/plain, */*
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: en-US,en;q=0.9
Connection: keep-alive
Content-Length: 62
Content-Type: application/json

{"refreshToken": "8EE8wwVZYkcHaItS4_ZHS5p2bLObAjQdkUXBhMyAQY8"}
```

```json title='Response with New Access Token'
{
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVC...",
    "refreshToken": "O2ThQ6aTSxN6PUbaFyFT9bn1xqZoR-MrSpNpWLBMdxw",
}
```
---

### Access Tokens vs Refresh Tokens

| | Access Token | Refresh Token |
|---|--------------|---------------|
| **Lifetime** | Minutes to hours | Days to months |
| **Format** | Usually JWT (self-contained) | Opaque string |
| **Usage** | Every API request | Token refresh only |
| **Storage** | Memory or httpOnly cookie | Backend database |
| **Revocation** | Difficult (stateless) | Easy (database lookup) |


---



### JWT in .NET

```csharp title='ApplicationBuilderExtensions.cs'

public static IHostApplicationBuilder AddAuthentication(this IHostApplicationBuilder builder){
    var jwtSettings = builder.GetJwtSettings();

    builder.Services.AddAuthentication(options =>{
        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    })
    .AddJwtBearer(options =>{
        options.TokenValidationParameters = new TokenValidationParameters{
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(jwtSettings.Secret),
            ValidateIssuer = true,
            ValidIssuer = jwtSettings.Issuer,
            ValidateAudience = true,
            ValidAudience = jwtSettings.Audience,
        };
    });

    return builder;
}

```

---

### Angular Interceptor

```typescript
export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const router = inject(Router);

  return next(req).pipe(
    catchError((error) => {
      if (error.status !== 401) {
        return throwError(() => error);
      }
      return authService.refreshToken().pipe(
        //Try again with the new token
        switchMap(() => next(req)),
        //Give up and sign out.
        catchError(() => {
          authService.signOut();
          router.navigate(['/signin']);
          return throwError(() => error);
        })
      );
    })
  );
};
```

---

### Token Storage

| Storage Location | Security | Persistence | XSS Risk | CSRF Risk |
|------------------|:-----------|:------------|:---------|:----------|
| **Memory only** | ðŸŸ¢ High | Session only | ðŸŸ¢ Low | ðŸŸ¢ Low |
| **localStorage** | ðŸ”´ Low | Persistent | ðŸ”´ High | ðŸŸ¢ Low |
| **sessionStorage** | ðŸŸ¡ Medium | Tab-scoped | ðŸ”´ High | ðŸŸ¢ Low |
| **HttpOnly Cookie** | ðŸŸ¢ High | Persistent | ðŸŸ¢ Low | ðŸŸ¡ Medium |

* Access tokens: short-lived (minutes to hours)
* Refresh tokens: long-lived (days to months), handle with care
* [OWASP Token Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html#token-storage-on-client-side)

---

### Hybrid Token Strategy

* **Web clients:** HttpOnly cookies protect against [XSS token theft](https://owasp.org/www-community/attacks/xss/)
* **Native clients:** Standard Bearer tokens (cookies don't work well)
* **Challenge:** Supporting both from same API endpoints
* **Solution:** Middleware transparently converts cookies â†’ Bearer header
* Downstream authentication sees only Bearer tokens (consistent)

---

### Cookie-to-JWT Middleware

```csharp title='CookieToJwtMiddleware.cs'
public class CookieToJwtMiddleware {
    private readonly RequestDelegate _next;

    public async Task InvokeAsync(HttpContext context) {
        if (!context.Request.Headers.ContainsKey("Authorization") 
            && Cookies.HasAccessToken(context)) {
            var accessToken = Cookies.GetAccessToken(context);
            context.Request.Headers.Append("Authorization", $"Bearer {accessToken}");
        }
        await _next(context);
    }
}
```

Register before `UseAuthentication()` in middleware pipeline

---

### JWT Evaluated
* **Strengths**:
  - Self-contained, no database lookup required
  - Supports federation and multiple services
  - Configurable claims and expiration
  - Scales horizontally without sticky sessions
* **Weaknesses**:
  - Difficult to revoke before expiration
  - Tokens are stealable if not using httpOnly cookies
  - Larger size than opaque tokens

---

## Fin

---

### Recap
1. What's the difference between **primary** and **session** authentication?
2. What's the difference between **access tokens** and **refresh tokens**?
3. Which token storage location has the highest **XSS risk**?

