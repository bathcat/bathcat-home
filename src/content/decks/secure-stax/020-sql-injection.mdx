---
title: "Sql Injection"
description: "Classic web app vulnerability that still happens all the time."
status: 'Live'
flavor: 'Deck'
---

# SQL Injection

---

### Goals
By the end of this deck, you should be able to answer--
1. What is **SQL injection** and why does it still happen?
2. Name 3 techniques to prevent SQL injection.
3. Which EF Core method is safer: `FromSqlRaw` or `FromSqlInterpolated`?
4. Why does SQL injection still matter if it's easy to prevent?


---

### Roadmap
1. Overview
2. Basics
3. Mitigation

---



## Overview

---

### SQL Injection in 2025
* Easy to mitigate with modern ORMs and frameworks
* Successful attacks declining year over year
* Not a solved problem, but **much better** than 2010

---

### But Why Still Care?
* **Classic trust fallacy** - Textbook example of trusting user input
* **Shame factor** - Classic blunder, like getting involved in a [land war in Asia](https://www.youtube.com/watch?v=7LUUk6wVNrY)
* **Devastating potential** - Write access to persistence is pretty bad
* **Easy to probe** - First thing attackers check for

---

### How Devastating?
* Inject **XSS into every page** served to clients
* Deploy **keyloggers** to every user session
* Turn your application into an attack platform
* One vulnerable endpoint can compromise entire userbase

---

### Data Exfiltration Reality
* **PII** - Names, addresses, social security numbers
* **Financial data** - Credit cards, bank accounts
* **Authentication** - Password hashes, session tokens, API keys
* **Business secrets** - Pricing, customer lists, proprietary data

---

### [Recent Victims](https://en.wikipedia.org/wiki/SQL_injection)
{/* TODO: Update with newer examples as they emerge */}
* [Cock.li email breach](https://socradar.io/major-cyber-attacks-june-2025/) (2025) - 1M+ users via Roundcube
* [MOVEit breach](https://en.wikipedia.org/wiki/2023_MOVEit_data_breach) (2023) - 2,700+ orgs, 93M individuals
* [Bulgarian Revenue Agency](https://www.bbc.com/news/world-europe-48925871) (2019) - 5M+ citizens

---

### When Vulnerabilities Sneak In
* Simple CRUD with LINQ? Hard to mess up
* **Dynamic queries** are the danger zone:
  * User selects N filter terms
  * Multiple "compare" checkboxes
  * Wildcard searches across fields
* Junior engineer reaches for [StringBuilder](https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=net-9.0)`StringBuilder`

---

### The Temptation

```csharp title='ProductRepository.cs'
var sql = "SELECT * FROM Products WHERE ";
foreach(var term in searchTerms){
    sql += "Name LIKE '%" + term + "%' OR ";
}
sql += "1=0";

var products = context.Products
    .FromSqlRaw(sql)
    .ToList();
```

---

### The Catch
* Attackers need **write access** for maximum damage
* [Timing attacks](https://owasp.org/www-community/attacks/Blind_SQL_Injection) like `WAITFOR` have low bandwidth
* Require additional vulnerabilities:
  * Leaked error messages (design/devops failure)
  * Poor operational logging (millions of slow queries unnoticed)

---



## Basics

---

### SQL Injection Defined 
* Code injection technique 
* Attacks data-driven applications
* Run malicious SQL statements through user input


---

### Example: [Exploits of a Mom](https://xkcd.com/327/)
<figure class='bc-figure-hero'>
![Exploits of a Mom](./assets/exploits_of_a_mom.png)
</figure>


---

### Injection Flavors
* Scary Input
  - Break stuff
* Exfiltrate information
  - Error messages
  - Blind Attacks


---

### Good News Everyone!
* It's easy to avoid
* Never combine user input with Entity SQL command text
* Don't
  - Trust user input
  - Concatenate SQL strings
* Choose an ORM


---

### Dumb Example
Don't do this:
```csharp title='UserRepository.cs'
statement = "SELECT * FROM users WHERE name = '" + userName + "';"
```
Because of this:
```csharp
a';DROP TABLE users; SELECT * FROM userinfo WHERE 't';--
```





---



### EF Core Review
* [DbContext](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext)
* [DbSet](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbset-1)
* [Entity Framework Core](https://docs.microsoft.com/en-us/ef/core/)


---

### No ADO.NET Required
* Even though EF Core exposes familiar classes like:
  * [SqlCommand](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlcommand)
  * [SqlCommandBuilder](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlcommandbuilder) 
  * [SqlConnection](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection)
* Ideally, everything happens through the [DbContext](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext)



---

### But You Can Still Execute SQL 
* Which means SQL Injection is still possible
* Two extension methods on `DbSet`:
  * [`FromSqlRaw`](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.relationalqueryableextensions.fromsqlraw)
  * [`FromSqlInterpolated`](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.relationalqueryableextensions.fromsqlinterpolated)


---

### Example [`FromSqlRaw`](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.relationalqueryableextensions.fromsqlraw)
```csharp title='BlogRepository.cs'
var user = getUserName();
var blogs = context.Blogs
    .FromSqlRaw("SELECT * FROM dbo.Blogs where userName = '" + user + "';")
    .ToList();
```
#### Bad Idea!


---

### Good News About `DbSet` Methods
* Results are still typed
* Can only be used on query roots
* One statement at a time


---

### Even Scarier: [DatabaseFacade](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.infrastructure.databasefacade)
* Provides database-level functionality
* Exposes `ExecuteSqlRaw`


---

### Example
```csharp title='SnakeRepository.cs'
            var query = "INSERT dbo.Snake(ID, Name, meannessLevel) VALUES(";
            query += "'" + toCreate.ID.ToString() + "', ";
            query += "'" + toCreate.Name + "', ";
            query += toCreate.MeannessLevel.ToString();
            query += ");";

            int result = this.context.Database.ExecuteSqlRaw(query);
            return this.Snakes.FirstOrDefault(s => s.ID == toCreate.ID);
```


---

### Why would you use a raw query?
* Performance - LINQ-generated SQL isn't always efficient 
* Expressiveness - LINQ and SQL aren't 100% equivalent
* Stupid database tricks
  * Table-valued function


---






## Mitigation


---

### Options (In Order)
1. Do everything with LINQ
1. Paramaterize/Interpolate queries
1. Use stored procedures
1. Sanitize by hand 
1. One weird trick


---

### Technique #1

#### No Direct SQL Execution in C# #
* Do everything with LINQ
* Benefits
  - Most programmers aren't very good at SQL anyway
  - Less tightly coupled to persistance mechanism


---

### Example
```csharp title='BlogRepository.cs'
var user = getUserName();
var blogs = context.Blogs
    .Where(b=>b.UserName == user)
    .Where(b=>b.Age > 10)    
    .ToList();
```
* `IQueryable` is technically a **monad** 
* Generates better SQL than you'd think

---

### Technique #2

#### Paramaterize your queries
* `FromSqlRaw` has an overload to pass parameters
* It looks like string interpolation 
* Actually gets turned into a DbParameter object


---

### Example
```csharp title='BlogRepository.cs'
var user = getUserName();
var blogs = context.Blogs
    .FromSqlRaw("SELECT * FROM dbo.Blogs where userName = {0}", user)
    .ToList();
```


---

### Technique #2 Variation

#### Interpolate your queries
* `FromSqlInterpolated` works like `FromSqlRaw`
* Allows interpolation syntax
* Effectively the same


---

### Example
```csharp title='BlogRepository.cs'
var user = getUserName();
var blogs = context.Blogs
    .FromSqlInterpolated("SELECT * FROM dbo.Blogs where userName = {user}")
    .ToList();
```



---

### Technique #3: Stored Procedures
* Not 100% safe
  * Dynamic SQL in the sproc is still vulnerable
* But it forces parameterization
* Drawbacks
  - Tight vendor coupling
  - DBA turnaround
  - Blunt instrument



---

### Example
```csharp title='BlogRepository.cs'
var user = new SqlParameter("user", "johndoe");

var blogs = context.Blogs
    .FromSqlRaw("EXECUTE dbo.GetMostPopularBlogsForUser @user", user)
    .ToList();
```


---

### Technique #4: Sanitize At Your Peril
* Escape possibly dangerous strings 
* Not an exact science
* Often possible to hack

```csharp title='MyCustomSanitizer.cs'
string SanitizeForDatabase(string input)=>
  => input.replace("@","")
          .replace("--", "")
          .replace("DROP TABLE","");

```

---

### Better Example
* Avoid explicit, programmatic sanitization
* Prefer higher-level abstractions
* But use a library if you must

<br/>

```csharp
Encoder oe = new OracleEncoder();
String query = "SELECT user_id FROM user_data WHERE user_name = '" 
+ oe.encode( req.getParameter("userID")) + "' and user_password = '" 
+ oe.encode( req.getParameter("pwd")) +"'";
```



---

### One Weird Trick
#### Table-Valued Parameters
* Enable the passing in of 'arrays'
* Advantages:
  * Single trip to the well
  * No dynamic sql generation

```csharp title='BlogRepository.cs'
var cmd = new SqlCommand("usp_FilterAssets", connection);  
cmd.CommandType = CommandType.StoredProcedure;  
var param = cmd.Parameters.AddWithValue("@conditions", conditions);  
param.SqlDbType = SqlDbType.Structured; 
```

---

## Fin

---

### Recap
1. What is **SQL injection** and why does it still happen?
2. Name 3 techniques to prevent SQL injection.
3. Which EF Core method is safer: `FromSqlRaw` or `FromSqlInterpolated`?
4. Why does SQL injection still matter if it's easy to prevent?

---

## Lab 10: SQL Injection

---

### Sql Injection Lab
* One branch has an ugly SQL injection vulnerability
* [Details here](https://github.com/bathcat/mango-bay/tree/main/docs/labs/10.sql-injection)
* **Goal**: Fix the vulnerability
