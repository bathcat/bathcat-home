---
title: "Auth"
description: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
status: 'Live'
flavor: 'Deck'
---

# Authorization, Authentication

---

### Goals
By the end of this deck, you should be able to answer--
1. What's the difference between **authentication** and **authorization**?
2. Why is **resource-based authorization** needed beyond simple role checks?
3. Name 2 strategies for implementing **resource-based authorization**.


---

### Roadmap
1. Overview
2. Authentication
3. RBAC
4. Resource-based Authorization

---

## Overview

---

### Two Flavors of Authentication
* **Primary authentication**: User provides credentials
  - Password, OAuth, 2FA, biometrics
  - User is present
* **Session authentication**: System validates token
  - Bearer tokens, cookies, session IDs
  - User is absent
* Explains why apps need multiple authentication schemes

---

### This Deck Is Different
* Not vulnerability → mitigation pattern
* More [Security Misconfiguration](https://owasp.org/Top10/2025/A02_2025-Security_Misconfiguration/) than code vulnerability
* Each OAuth provider has unique quirks
* Integration work > security engineering
* Why Auth0/Okta exist: abstract configuration hell

---

### Tokens Are The Target Now
* 2FA makes credentials harder to steal
* UX demands longer sessions (Netflix, IoT, mobile)
* The paradox: better credential security → more valuable tokens
* Token theft/manipulation is the attack vector
* Next deck: token security, storage, JWT

---

### Authorization Matters Most
* [Broken Access Control](https://owasp.org/Top10/2025/A01_2025-Broken_Access_Control/) is OWASP Top 10 #1 (2025)
* Authentication gets you in the door
* Authorization decides what you can touch
* Resource-based authorization is where it gets sophisticated

---







## Authentication


---

### Options
* Forms - i.e. username/password
* Single Sign On 
  - Windows Authentication
  - Jwt
* External Provider
  - Oauth, Google, Facebook
* Mix and match



---

### [ASP.NET Core Identity](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity)
* Includes UI for
  * End users
  * Management
* Lots of features to manage 
  - Users, Profiles
  - Passwords
  - Roles, Claims, Tokens


---

### Popular: [Windows Authentication](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/windowsauth)
* Great for intranet apps
* Supported by
  * IIS 
  * HTTP.sys
  * Kestrel _No NTLM option_
* No Windows Requirement


---

### `launchSetting.json`
{/* TODO: Update this */}
```json title='launchSetting.json'
"iisSettings": {
    "windowsAuthentication": true,
    "anonymousAuthentication": false,
}
```


---

### Schemes and Handlers
* ___[Authentication Handler](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.authenticationhandler-1)___ does the actual work
* ___[Authentication Scheme](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/?view=aspnetcore-9.0#authentication-scheme)___ 
  - Configures the handler instance
  - Functions as a handle for other components to reference


---

### Key Player: [Identity Server](https://identityserver.io/)
* Microsoft's Open ID Implementation
* Authentication as a microservice


---

### Step 1: Configure Services
```csharp title='ServiceCollectionExtensions.cs'
	services.AddDefaultIdentity<SnakesUser>()
	        .AddEntityFrameworkStores<SnakesDbContext>();

	services.AddAuthentication()
	        .AddIdentityServerJwt();	        
```


---

### Variation
```csharp title='ServiceCollectionExtensions.cs'
services
  .AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
  .AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, options => Configuration.Bind("JwtSettings", options))
  .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, options => Configuration.Bind("CookieSettings", options));
```




---

### Step 2: Consume Services
{/* TODO: Consolidate this into a title=Program.cs */}
```csharp title='Program.cs'
  app.UseAuthentication();
```




---

## RBAC

---

### What's [RBAC](https://en.wikipedia.org/wiki/Role-based_access_control)?
* <u>R</u>ole-<u>B</u>ased <u>A</u>ccess <u>C</u>ontrol
* Users assigned to roles, roles granted permissions
* Simple and battle-tested
* Easy to reason about, hard to screw up
* When you can express authorization as RBAC, do it
* [NIST standard](https://csrc.nist.gov/projects/role-based-access-control) since 1992

---

### Overview
* Easy things are easy
  * e.g. Group membership 
* Sophistication is possible
  * Granular claims
  * Complex combinations


---

### Step 1: Define a Policy
```csharp title='AdministratorAuthorizationPolicy.cs'
public static class AdministratorAuthorizationPolicy 
{
    public static string Name => "SnakesAdministrators";
 
    public static void Build(AuthorizationPolicyBuilder policy) =>
        policy.RequireClaim("groups", "c5038c6f-c5bc-43d5-93f5-44ec607d62dc");    
}
```


---

### Step 2: Configure Services
```csharp title='ServiceCollectionExtensions.cs'
public static void ConfigureAuthorization(this IServiceCollection services)
{
    services.AddAuthorization(options =>
    {
        options.AddPolicy(AdministratorAuthorizationPolicy.Name, 
                          AdministratorAuthorizationPolicy.Build);
    });
    // ...
}
```


---

### Step 3: Consume
```csharp {17} title='SnakeEndpoints.cs'
    public static void MapSnakeEndpoints(this WebApplication app){
        ArgumentNullException.ThrowIfNull(app);

        var snakesGroup = app.MapGroup(ApiRoutes.Snakes)
            .WithTags("Snakes");

        snakesGroup.MapGet("/", GetSnakes)
            .WithName("GetSnakes")
            .Produces<Page<SnakeDto>>(StatusCodes.Status200OK)
            .WithDescription("Retrieves a paginated list of snakes.");

        snakesGroup.MapPost("/", CreateSnake)
            .WithName("CreateSnake")
            .Produces<SnakeDto>(StatusCodes.Status201Created)
            .Produces(StatusCodes.Status400BadRequest)
            .WithDescription("Creates a new snake.")
            .RequireAuthorization(policy => policy.RequireRole(UserRoles.Administrator));
    }
```


---

### Alternative: Claims-Based
* Canonical example: Buying beer
* Bartenders don't care who you are
* They just want evidence you're > 21


---

### It's all Middleware
```csharp title='Over21AuthorizationPolicy.cs'
public static class Over21AuthorizationPolicy 
{
    public static string Name => "Over21";
 
    public static void Build(AuthorizationPolicyBuilder policy) {
		policy.AuthenticationSchemes.Add(JwtBearerDefaults.AuthenticationScheme);
		policy.RequireAuthenticatedUser();
		policy.Requirements.Add(new MinimumAgeRequirement());
    }
}

```



---



## Resource-based Authorization

---

### The Problem with Pure RBAC
* Real authorization often depends on **relationship to a resource**
* Example: Amazon order access
* Who can view order #12345?
  - Administrator ✓
  - Customer who placed the order ✓
  - Assigned delivery driver ✓
  - Warehouse supervisor for shipping site ✓
* Role membership alone isn't enough

---

### Anti-pattern: IDOR
```csharp title='DeliveryService.cs'
public Task<Page<Delivery>> GetByCustomer(Guid customerId, int skip, int take)
 => _deliveryStore.GetByCustomerId(customerId, skip, take);
```

**Problems:**
* No authorization check at all!
* Anyone can query any customer's deliveries

---

### Pattern: Split by Role
```csharp title='DeliveryService.cs' {3,9}
public async Task<Page<Delivery>> GetByCurrentCustomer(int skip, int take)
{
    _authorizationService.ThrowIfUnauthorized([UserRoles.Customer]);    
    return await _deliveryStore.GetByCustomerId(customerId, skip, take);
}

public async Task<Page<Delivery>> GetByCustomer(Guid customerId, int skip, int take)
{
    _authorizationService.ThrowIfUnauthorized([UserRoles.Administrator]);
    return await _deliveryStore.GetByCustomerId(customerId, skip, take);
}
```

**Better**, but doesn't scale with complex role hierarchies

---

### Reality Check
* **Authentication**, **Authorization**, and **Business Logic** seem orthogonal
* True for RBAC: "Is user an admin?"
* **False for resource authorization**: "Does user own this order?"
* Resource authorization **is** business logic
* Can't separate them cleanly

---

### Architectural Decision: Where?
* **Option 1: Endpoints/Controllers**
  - ✓ Clear security boundary
  - ✓ Easy to audit
  - ✗ Must duplicate for WebSockets, BFF, gRPC, etc.
* **Option 2: Service Layer**
  - ✓ Single source of truth
  - ✓ Reusable across APIs
  - ✗ Mingles business logic with authorization logic

**Recommendation**: Services layer when authorization is business logic

---

### Imperative Style: Explicit Checks
```csharp title='DeliveryController.cs' {2-7}
public async Task<Result> BookDelivery(Guid customerId, DeliveryRequest request){
    _authorizationService.ThrowIfUnauthorized([UserRoles.Customer, UserRoles.Administrator]);
    
    if (!_currentUser.IsInRole(UserRoles.Administrator) &&
        _currentUser.CustomerId != customerId){
        throw new UnauthorizedAccessException("You can only book for yourself.");
    }
    
    return await _deliveryService.BookDelivery(customerId, request);
}
```

---

### Imperative Style Evaluated
**Strengths:**
* Explicit and easy to understand
* No magic or abstraction
* IDE autocomplete works well
* Easy to debug

**Weaknesses:**
* Verbose and repetitive
* Hard to test in isolation
* Authorization scattered across codebase
* Difficult to audit globally

---

### Declarative Style: Authorization Handlers
* Microsoft's `IAuthorizationHandler<TRequirement, TResource>`
* Separates authorization policy from business logic
* Testable and reusable
* [Microsoft Docs: Resource-based authorization](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/resourcebased)

---
### Example

```csharp title='DeliveryAuthorizationHandler.cs'
public class DeliveryAuthorizationHandler 
    : AuthorizationHandler<OperationAuthorizationRequirement, Delivery>{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        OperationAuthorizationRequirement requirement,
        Delivery resource){
        if (requirement.Name == "Read" && CanReadDelivery(context.User, resource)){
            context.Succeed(requirement);
        }
        
        return Task.CompletedTask;
    }
    
    private bool CanReadDelivery(ClaimsPrincipal user, Delivery delivery) =>
        user.IsInRole(UserRoles.Administrator) ||
        user.GetCustomerId() == delivery.CustomerId ||
        user.GetDriverId() == delivery.AssignedDriverId;
}
```

---

### Using Authorization Handlers
```csharp title='DeliveryController.cs' {7-14}
public async Task<Result<Delivery>> GetDelivery(Guid deliveryId){
    var delivery = await _deliveryStore.GetById(deliveryId);
    if (delivery is null){
        return Result.NotFound();
    }
    
    var authResult = await _authorizationService.AuthorizeAsync(
        _currentUser, 
        delivery, 
        Operations.Read);
    
    if (!authResult.Succeeded){
        return Result.Forbidden();
    }
    
    return Result.Success(delivery);
}
```

---

### Performance Considerations
**Problem**: Loading entire resource just to check authorization

```csharp title='DeliveryService.cs'
var order = await _context.Orders
    .Include(o => o.LineItems)
    .Include(o => o.Customer)
    .FirstOrDefaultAsync(o => o.Id == orderId);

if (order.CustomerId != currentUser.CustomerId)
{
    throw new UnauthorizedAccessException();
}
```
---

### Performance Considerations (II)
**Better**: Authorization queries

```csharp title='DeliveryService.cs'
var canAccess = await _context.Orders
    .Where(o => o.Id == orderId)
    .AnyAsync(o => o.CustomerId == currentUser.CustomerId);

if (!canAccess)
{
    throw new UnauthorizedAccessException();
}

var order = await _context.Orders
    .Include(o => o.LineItems)
    .Include(o => o.Customer)
    .FirstOrDefaultAsync(o => o.Id == orderId);
```

---

### Query Filtering vs Throwing
**Throwing (403 Forbidden):**
```csharp title='DeliveryService.cs'
var order = await _orderStore.GetById(orderId);
if (order.CustomerId != currentUser.CustomerId)
{
    throw new UnauthorizedAccessException();
}
```

**Filtering (empty results):**
```csharp title='DeliveryService.cs'
var orders = await _context.Orders
    .Where(o => o.CustomerId == currentUser.CustomerId)
    .ToListAsync();
```

**Choose based on UX**: Does user know resource exists?

---

### Common Patterns
* **Ownership**
  - Very common
  - Check `resource.OwnerId == currentUser.Id`

* **Multi-tenancy**
  - Resource-based auth in disguise
  - Check `resource.TenantId == currentUser.TenantId`

* **Hierarchical Access**
  - Manager sees team's resources
  - Check relationships in organization hierarchy

* **Time-based**
  - Access expires after deadline
  - Check `resource.ExpiresAt > DateTime.UtcNow`

---

### Testing Resource Authorization
```csharp title='DeliveryService.Tests.cs'
[Fact]
public async Task Customer_CannotAccess_OtherCustomerDeliveries(){
    var customer1 = TestUsers.Customer1;
    var customer2 = TestUsers.Customer2;
    var delivery = await CreateDelivery(customer2.Id);
    
    _currentUser.SetUser(customer1);
    
    await Assert.ThrowsAsync<UnauthorizedAccessException>(
        () => _deliveryService.GetDelivery(delivery.Id));
}
```
---

### Example (II)
```csharp title='DeliveryService.Tests.cs'
[Fact]
public async Task Administrator_CanAccess_AllDeliveries(){
    var customer = TestUsers.Customer1;
    var admin = TestUsers.Administrator;
    var delivery = await CreateDelivery(customer.Id);
    
    _currentUser.SetUser(admin);
    
    var result = await _deliveryService.GetDelivery(delivery.Id);
    
    Assert.NotNull(result);
    Assert.Equal(delivery.Id, result.Id);
}
```

---

## Fin

---

### Recap
1. What's the difference between **authentication** and **authorization**?
2. Why is **resource-based authorization** needed beyond simple role checks?
3. Name 2 strategies for implementing **resource-based authorization**.







