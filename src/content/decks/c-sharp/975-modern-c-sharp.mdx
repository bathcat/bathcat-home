---
title: "Modern C Sharp"
description: "Potpourri of new(ish) C# features. Not all of which will change your life."
status: 'Draft'
flavor: 'Deck'
---
# Modern C#

---

### Goals

1. Lorem
2. Ipsum
3. Sic

---




## Expresion Bodies

---

### Overview
* Terse implemention allows using expression bodies instead of traditional code blocks
* Introduced with C# 6, enhanced by C# 7
* Used for:
  - Method
  - Property
  - Constructor, Finalizer
  - Indexer

---

### Motivating Example 

```csharp
class User{
  string FullName {
    get{
      return $"{this.surname}, {this.givenName}";
    }
  }

  override ToString(){
    return $"[{this.FullName}];
  }
}

```

---

### Terse

```csharp
class User{
  string FullName 
    => $"{this.surname}, {this.givenName}";

  override ToString() 
    =>  $"[{this.FullName}];
}
```

---




## Fancy `using`

---


### Overview
* Old-school C# requires you to import _all_ namespaces with the `using` keyword
* Contemporary developers have options:
  - [Global](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/globalusingdirective) introduced by C# 6
  - [Implicit](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives) introduced by C# 10
* **Advantages**: Less boilerplate, friendlier to newbies
* **Complaints**: Not as explicit, minimal time savings

---




## Top-level Statements

---

### Overview
* [Introduced in C# 9](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements)

> Top-level statements enable you to avoid the extra ceremony
> required by placing your program's entrypoint in a static method in a class.

#### Old and busted **App.cs**

```csharp
using System;
namespace Acme{
  public static void App{
    public static void Main(){
      Console.Writeline("Hello world!);
    }
  }
}


```

---

### New Hotness
* Restrictions:
  - One top-level file per project
  - Live in the global namespace
  - Compiled into a `Main` method by the C# Compiler

```csharp
      Console.Log("Hello world!);
```

---

### Pros and Cons
* **Advantages**
  - Less boilerplate
  - Friendler to newbies
* **Disadvantages**
  - Looks weird to old people
  - Reduced uniformity


---






## Pattern Matching

---



### Overview

* Introduced in C# 7.0, inspired by functional languages like F# and Haskell
* Solves complex type checking and property matching in a declarative way
* Reduces boilerplate code for type testing and property extraction
* Enables more expressive and readable conditional logic
* Key features:
  - [Type patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#type-patterns) for safe type testing
  - [Property patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#property-pattern) for object property matching
  - [Positional patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#positional-pattern) for deconstructing objects
  - [List patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#list-patterns) for array/list matching (C# 11)

---

### Type Pattern Matching

* Tests and extracts values based on type using `is` operator
* Eliminates need for explicit type casting and null checks
* Introduced in C# 7.0 with [basic type patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#type-patterns)
* Enhanced in C# 9.0 with [relational patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#relational-patterns)
* Common use cases:
  - Safe type testing without exceptions
  - Extracting values from polymorphic objects
  - Combining type checks with property access

---

### Motivating Example

```csharp
public string ProcessShape(Shape shape){
    if (shape is Circle){
        var circle = (Circle)shape;
        return $"Circle with radius {circle.Radius}";
    }
    if (shape is Rectangle){
        var rect = (Rectangle)shape;
        return $"Rectangle {rect.Width}x{rect.Height}";
    }
    return "Unknown shape type";
}
```

---



### Type Pattern Example

```csharp
public string ProcessShape(Shape shape)
{
    if (shape is Circle circle)
        return $"Circle with radius {circle.Radius}";
        
    if (shape is Rectangle rect)
        return $"Rectangle {rect.Width}x{rect.Height}";
        
    if (shape is null)
        return "No shape provided";
        
    return "Unknown shape type";
}
```

---

### Property Pattern Matching

* Tests object properties directly in pattern matching expressions
* Introduced in C# 8.0 with [property patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#property-pattern)
* Enhanced in C# 10.0 with [extended property patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#extended-property-patterns)
* Common use cases:
  - Matching on object state without type checking
  - Combining multiple property conditions
  - Nested property access in patterns

---

### Property Pattern Example

```csharp title='OrderProcessor.cs'
public string GetOrderStatus(Order order)
{
    if (order is { Status: OrderStatus.Pending, Amount: > 1000 })
        return "High value pending order";
        
    if (order is { Customer: { IsVIP: true }, Status: OrderStatus.Processing })
        return "VIP order in processing";
        
    if (order is { Status: OrderStatus.Cancelled, CancellationReason: not null })
        return $"Order cancelled: {order.CancellationReason}";
        
    return "Standard order";
}
```

---

### Positional Pattern Matching

* Matches on object deconstruction using [positional patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#positional-pattern)
* Works with types that implement [Deconstruct](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct)
* Common use cases:
  - Matching on record types
  - Working with tuple-like structures
  - Extracting multiple values in one pattern

---

### Positional Pattern Example

```csharp title='PointProcessor.cs'
public string GetQuadrant(Point point) {
    return point switch {
        (0, 0) => "Origin",
        (var x, var y) when x > 0 && y > 0 => "Quadrant 1",
        (var x, var y) when x < 0 && y > 0 => "Quadrant 2",
        (var x, var y) when x < 0 && y < 0 => "Quadrant 3",
        (var x, var y) when x > 0 && y < 0 => "Quadrant 4",
        _ => "Invalid point"
    };
}
```

---

### List Pattern Matching

* Introduced in C# 11 with [list patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#list-patterns)
* Matches on array or list elements using slice patterns
* Common use cases:
  - Matching sequence prefixes
  - Extracting head and tail elements
  - Validating list structure
* Supports `..` for slice patterns and `_` for discards

---

### List Pattern Example

```csharp title='CommandParser.cs'
public string ParseCommand(string[] args) 
    => args switch {
        ["run", "test", ..] => "Running tests",
        ["build", "release", var target] => $"Building release for {target}",
        ["help", var command] => $"Showing help for {command}",
        ["version"] => "v1.0.0",
        [] => "No command provided",
        _ => "Unknown command"
    };

```
---



## Keyword: `using`

---

### Overview
* `using` has multiple uses
  - Namespace imports
  - Type imports
  - Resource management (to be covered later)
* Lots of approaches

---

### Approach 0: No `using`
* No `using` directives
* Fully qualified names
* No one really does this
* BUT it's how the CLR works


---

### Example: No `using`

```csharp
class MyClass{
  public void DoWork(){
    var fs = new System.IO.FileStream("file.txt", System.IO.FileMode.Open);
    var reader = new System.IO.StreamReader(fs);
    var line = reader.ReadLine();
    System.Console.WriteLine(line);
  }
}

```

---

### Approach 1: Manual Import
* Recipe: Add `using` directives to every file
* **Pros**: Explicit, Traditional
* **Cons**:
  - Less friendly to newcomers
  - Tedious (?)
  
---

### Example: Manual Import
```csharp
using System.IO;
using System;

class MyClass{
  public void DoWork(){
    var fs = new FileStream("file.txt", FileMode.Open);
    var reader = new StreamReader(fs);
    var line = reader.ReadLine();
    System.Console.WriteLine(line);
  }
}

```

---

### Approach 2: Global Usings
* [Global Usings](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive#global-modifier) allow namespace imports to be shared across multiple files
* Introduced in C# 10/.NET 6
* Recipe: 
  - Create a `global.cs` file
  - Add `using` directives to it
* **Pros**: Convenient, Easy to manage
* **Cons**: Less explicit, Potential collisions

---

### Example: Global Usings
```csharp title="global.cs"
using System.IO;
using System;
```

---

### Approach 3: Implicit Usings
* Introduced in [.NET 6/C# 10](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives)
* Automatically imports common namespaces based on project type
* Configured in project file
* **Pros**: Less boilerplate, Standardizes imports across projects
* **Cons**: Less explicit, Potential namespace collisions

---
### Example: Implicit Usings
```xml title="MyProject.csproj"
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

```

---

### Takehome
* Choice of `using` approach comes down to style
* **Most important**: be consistent within your project or organization
* Documentation and IDE support work equally well with all approaches

