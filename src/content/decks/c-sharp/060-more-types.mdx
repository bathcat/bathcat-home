---
title: "More Types!"
description: "More advanced C# type concepts including the use cases for structs, enumerations (including flags), tuples, and records. (Because records are awesome!)"
status: 'Live'
flavor: 'Deck'
---




# More Types!

---

### Goals

1. Explain when to use a `struct` instead of a `class`.
2. Describe the use case for `enum`
3. Name 2 advantages of `tuple` 
4. List 3 advantages of using `record` over `class`

---

### Outline
1. [Overview](#overview)
1. [System.Struct](#systemstruct)
2. [Enumerations](#enumerations)
3. [Tuples](#tuples)
4. [Records](#records)

---



## Overview

---

### Refresher: Value vs Reference Types

* [**Value types**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types) (structs, enums) are allocated inline
  - Pass by value, assignment by value
  - Destroyed when out of scope
* [**Reference types**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types) (classes, interfaces) are allocated on the heap
  - Reference types store a pointer to the data, pass by reference
  - Pass by reference, assignment by reference
  - Garbage collected


---

### Motivating Example
```csharp
using System.Collections;

// Avoid ArrayList! Use List<T> instead.
var mixedList = new ArrayList();
mixedList.Add(42);          // Boxing int
mixedList.Add("World");

// Requires type checking and casting
if (mixedList[0] is int number) {
    Console.WriteLine($"Number: {number}");
}
if (mixedList[1] is string text) {
    Console.WriteLine($"Text: {text.ToUpper()}");
}

// Direct casting needed, can cause errors
int num = (int)mixedList[0];
string str = (string)mixedList[1];
```

---

### Refresher: [ArrayList](https://learn.microsoft.com/en-us/dotnet/api/system.collections.arraylist)
* [Legacy collection](https://learn.microsoft.com/en-us/dotnet/api/system.collections.arraylist) (pre-.NET 2.0 generics).
* Stores elements as [`object`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types#the-object-type)
* Problems 
  - losing compile-time type safety.
  - Requires explicit casting when retrieving items.
  - Causes [boxing/unboxing](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing) for value types (performance cost).
* Pre-generic alternative: custom type-specific collections.

---

### What's boxing?
* [Boxing](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is converting a **value type** (like `int`, `struct`) to a reference type (`object` or an interface).
* The runtime allocates a "box" object on the **heap** and copies the value type's data into it.
* **Why it matters:**
    *   Adds **performance overhead** (heap allocation, copy).
    *   Increases **memory usage** and GC pressure.
    *   Can happen implicitly, especially with older non-generic collections like `ArrayList`.
* [Unboxing](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing) (extracting the value) also has type-checking and copying costs.

---

### Example 1: Variables and Parameters
```csharp
int number = 42;
object obj = number; // Boxing
IConvertible convertible = number; // Boxing!
int unboxed = (int)obj; // Unboxing

public void PrintValue(object value){
  Console.WriteLine(value);
}
PrintValue(number); // Boxing

```

---

### Example 2: Data Members

```csharp
public class Holder{
  public Object Held;
}

var holder = new Holder{
  Held = 42 // Boxing
};

// Make it generic to avoid boxing!
public class GenericHolder<T>{
  public T Held;
}

var genericHolder = new GenericHolder<int>{
  Held = 42 // No boxing
};

```


---

### Takeaways
* Remember 2 things:  
  - Boxing occurs when a value type is assigned to a variable, parameter, or field of type `object` or an interface type.
  - Boxing is expensive
* Solutions
  - **Use [Generics](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics)** 
  - Don't worry too much. **Avoid premature optimization**

---






## System.Struct

---

### System.Struct
* [System.Struct](https://learn.microsoft.com/en-us/dotnet/api/system.struct) is the base type for all value types
* Works like a class... with some differences
* Use `struct` for small, simple types that are not reference types
  - e.g. `Point`, `Color`, `Date`, `Time`
* In practice, you'll almost always use `class`

---

### Structs You've Met
*   Most built-in ["primitive" types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types) are structs:
    *   [`int`](https://learn.microsoft.com/en-us/dotnet/api/system.int32) (`System.Int32`)
    *   [`double`](https://learn.microsoft.com/en-us/dotnet/api/system.double) (`System.Double`)
    *   [`bool`](https://learn.microsoft.com/en-us/dotnet/api/system.boolean) (`System.Boolean`)
    *   [`decimal`](https://learn.microsoft.com/en-us/dotnet/api/system.decimal) (`System.Decimal`)
*   Other common value types:
    *   [`DateTime`](https://learn.microsoft.com/en-us/dotnet/api/system.datetime)
    *   [`Guid`](https://learn.microsoft.com/en-us/dotnet/api/system.guid)

---

### Examples

```csharp
public struct Point2D{
  public int X {get; set;}
  public int Y {get; set;}
}

public struct Point3D{
  public int X {get; set;}
  public int Y {get; set;}
  public int Z {get; set;}
}

public struct Color{
  public byte R {get; set;}
  public byte G {get; set;}
  public byte B {get; set;}
}
```

---

### Takeaways
* For a custom type, you **almost always want to use a class**
* Use `struct` when your type is
  - Logically represents a single value e.g. `Point`, `Color`, `Date`
  - ___There's some compelling reason___ like performance


---




## Enumerations

---

### [Overview](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum)

* [Enumeration type](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum) maps labels to integral values
* Provides type safety over magic numbers/strings
* Supports [bit flags](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum#enumeration-types-as-bit-flags) with `[Flags]` attribute
* Values can be [explicitly specified](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum#enumeration-types-as-bit-flags)
* Best practice: Use for fixed sets of related values

---

### Motivating Example #1
* Booleans aren't extensible

```csharp {3}
public class Login{
    string username = "";
    bool isActive = false; // TODO: Support Paused / Suspended
}
```

---

### Motivating Example #2

* Magic constants are easy to forget, easy to mess up
```csharp {3}
public class Login{
    string username = "";
    int statusCode = 22; //What's this?
}
```


---

### Example

```csharp {8}
enum Status{
  Active,
  Paused,
  Suspended
}
public class Login{
    string username = "";
    Status MyStatus = Status.Active;
}
```

---

### Example 2: Colors

```csharp title='ColorWavelengths.cs'
// Use an enum as a named set of constants
enum ColorWavelength {
    Red = 700,
    Orange = 600,
    Yellow = 580,
    Green = 550,
    Blue = 470,
    Violet = 400
}

public string GetColorInfo(ColorWavelength color) =>
    $"{color} light has a wavelength of {(int)color}nm";

```

---

### Flags

* Use [`[Flags]` attribute](https://learn.microsoft.com/en-us/dotnet/api/system.flagsattribute) for enums that represent bit fields
* Flag values must be powers of 2 for bitwise operations
* Enables [combining multiple values](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum#enumeration-types-as-bit-flags) with bitwise OR (`|`)
* Perfect for permission systems, settings, or option combinations
* Use plural names for flag enums (e.g., `Permissions`, `Options`)
* [`Enum.HasFlag()`](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag) tests if a specific flag is set

---

### Example

```csharp title='DaysOfWeek.cs'
[Flags]
public enum DaysOfWeek
{
    None      = 0,
    Sunday    = 1,
    Monday    = 2,
    Tuesday   = 4,
    Wednesday = 8,
    Thursday  = 16,
    Friday    = 32,
    Saturday  = 64,
    Weekdays  = Monday | Tuesday | Wednesday | Thursday | Friday,
    Weekend   = Saturday | Sunday,
    AllDays   = Weekdays | Weekend
}
```

---

### Using Flags

```csharp title='ScheduledEvent.cs'
public class ScheduledEvent
{
    public string Name { get; set; }
    public DaysOfWeek Schedule { get; set; }
    
    public bool IsScheduledOn(DaysOfWeek day) => 
        Schedule.HasFlag(day);
    
    public void AddDay(DaysOfWeek day) => 
        Schedule |= day;
        
    public void RemoveDay(DaysOfWeek day) => 
        Schedule &= ~day;
}

// Usage example
var meetup = new ScheduledEvent { 
    Name = "Team Meeting",
    Schedule = DaysOfWeek.Monday | DaysOfWeek.Wednesday | DaysOfWeek.Friday
};

```

---

### Framework Examples

* [`FileAttributes`](https://learn.microsoft.com/en-us/dotnet/api/system.io.fileattributes) - File and directory attributes
* [`ConsoleModifiers`](https://learn.microsoft.com/en-us/dotnet/api/system.consolemodifiers) - Keyboard modifier keys 
* [`BindingFlags`](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.bindingflags) - Reflection binding options
* [`RegexOptions`](https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions) - Regular expression behavior
* [`DateTimeStyles`](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.datetimestyles) - DateTime parsing options

---

### Best Practices

* Default enum value is 0, [always define it meaningfully](https://learn.microsoft.com/en-us/dotnet/api/system.enum)
* Use [PascalCase](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions#naming-enums) for enum names and members
* Use singular names for most enums, plural for [Flags](https://learn.microsoft.com/en-us/dotnet/api/system.flagsattribute)
* Prefer enums over magic numbers or magic strings
* Consider using [string representations](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getname) for serialization/display

---





## Tuples

---

### Overview
* [Tuples](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples) are lightweight containers for multiple values
* Like a list:
  - Members are sequential
  - Members aren't necessarily named
* Like a class:
  - Members _can_ be [named](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples#tuple-field-names)
  - Members are statically typed and heterogeneous
  - Value equality is built-in

---

### Example 1: 

```csharp
// Tuple with anonymous members
var person = (30, "John");
Console.WriteLine("PersonID"+person.Item1);

// Tuple with named members
var point = (x: 10, y: 20);
Console.WriteLine("PointX"+point.x);
```

---

### Example 2: Multiple Return Values

```csharp
public (bool Success, string Name) TryGetPersonName(int id){
  if(id == 1){
    return (Success: true, Name: "John");
  }
  return (Success: false, Name: "Not found");
}

// Tuples can use 'destructuring assignment'
var (success, name) = TryGetPersonName(1);
if(success){
  Console.WriteLine("Name"+name);
}
```

---

### Example 3: Min/Max

```csharp
public (int, int) GetMinMax(int[] numbers){
  return (numbers.Min(), numbers.Max());
}

```




---

### Pros and Cons
* **Pros**: Convenient, lightweight, support deconstruction
* **Cons**: Limited functionality, no built-in methods


---

### Takeaways
* Great for lightweight grouping, especially multiple return values from methods.
* Prefer named members for readability: `(bool Success, string Message)`
* Use a `class` or `record` for more complex data structures.
* Modern tuples (`ValueTuple`) are value types, good for performance.


---





## Records

---

### Overview
* Introduced by C# 9, refined by C# 10
* Terse syntax for encapsulating data
  - Great for DTOs
  - Just a class under the hood
* Usually [immutable](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#immutability)
* Freebies
  - Value equality
  - `GetHashCode`
  - Sensible default for `ToString`

---

### Motivating Example

```csharp

public class DayOfYear{
  public int Month {get;set;} = 1;
  public int Day {get;set;} = 1;

  public bool Equals(object o){
    o is DayOfYear other && other.Month = this.Month && other.Day==this.Day;
  }
  //TODO: Implement GetHashCode too
}

```

---

### Keyword `record` to the Rescue!
* Known as a 'primary constructor'
* Creates read-only properties for each argument
```csharp
public record DayOfYear(int Month, int Day);
```

---

### Slightly More Explicit

```csharp
public record DayOfYear{
  public required int Month {get;init;}
  public required int Day {get;init;}
}

```


---

### On Immutability
* **Advantages:** 
  - Easier to reason about
  - Harder to screw up-- especially when sharing state
* **Disadvantages:**
  - Replacing mutation with copying adds memory churn

---

### Keyword: `with`
* Enables ['nondestructive mutation'](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#nondestructive-mutation)
* In reality, a fancy way to copy Records

```csharp
public record Login(string ID, string Name, bool isActive, DateTime? DisabledOn);

public static LoginManager{
  public static Login Disable(Login login)
    => login with{
        IsActive = false,
        DisabledOn = DateTime.UtcNow
      };
}

```




---

### Deconstruction Example

```csharp title='Deconstruction.cs'
public record Person(string FirstName, string LastName, int Age);

// Create a record
var developer = new Person("Ada", "Lovelace", 36);

// Deconstruct into separate variables
var (first, last, years) = developer;
Console.WriteLine($"{first} {last} is {years} years old");

// Deconstruct in a switch expression
string GetLifeStage(Person person) => person switch {
    (_, _, < 18) => "Child",
    (_, _, < 65) => "Adult",
    _ => "Senior"
};

// Ignore parts you don't need
var (firstName, _, _) = developer;
```

---

### Takeaways
*   Excellent for [immutable data containers](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#immutability) (like DTOs).
*   Use concise **positional syntax**: `public record Person(string Name, int Age);`
*   Provides **value-based equality**, `ToString`, `GetHashCode` automatically.
*   Use [`with`-expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#nondestructive-mutation) for easy copying and modification.
*   Default is `record class`; [`record struct`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#record-structs) also exists for value types.

---




## Fin

---

### Review

1. Explain when to use a `struct` instead of a `class`.
2. Describe the use case for `enum`
3. Name 2 advantages of `tuple` 
4. List 3 advantages of using `record` over `class`
