---
title: "Exceptions"
description: "An overview of C# exception handling, covering how to throw, catch, and manage exceptions, with best practices for error handling and resource cleanup.."
status: 'Live'
flavor: 'Deck'
---




# Exceptions

---

### Goals

1. Explain when to throw exceptions versus using return values
3. List three common exception types and when to use them
4. Explain why catching `Exception` is generally discouraged
5. Describe the purpose of the `finally` block


---

### Outline

1. [Overview](#overview)
2. [Syntax: Throwing](#syntax-throwing)
3. [Syntax: Catching](#syntax-catching)
4. [Syntax: Finally](#syntax-finally)

---




## Overview

---


### What's an Exception?
#### From [Microsoft:](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/)
> The C# language's exception handling features help you deal with any unexpected or
> exceptional situations that occur when a program is running. Exception handling uses 
> the `try`, `catch`, and `finally` keywords to try actions that may not succeed, to handle 
> failures when you decide that it's reasonable to do so, and to clean up resources 
> afterward. 

---

### More Intuitive Explanation

*   Think of exceptions as **alarms** for unexpected problems
*   They signal something went wrong, stopping normal program flow
*   Use them for **_exceptional_** situations, not routine checks
*   C# provides tools (`try`, `catch`, `finally`) to manage these alarms

---

### Keywords 
* **Keyword [`try`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#the-try-statement)** for code that might throw an exception
* **Keyword [`catch`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#the-try-catch-statement)** for code to execute if an exception occurs
* **Keyword [`finally`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#the-try-finally-statement)** for code that executes no matter what

---

### Example

```csharp
try{// --- Code that might fail ---
    int[] numbers = { 1 };
    Console.WriteLine(numbers[5]); // Throws IndexOutOfRangeException
}
catch (IndexOutOfRangeException ex){
    Console.WriteLine("Error: Index was out of bounds.");
}
finally{
    // Optional: Code that always runs
    Console.WriteLine("Cleanup or final steps here.");
}
Console.WriteLine("Execution continues...");
```

---

### Exceptions in C#
* All exceptions inherit from [System.Exception](https://learn.microsoft.com/en-us/dotnet/api/system.exception)
* Exception objects contain details about the error
* Framework provides many built-in exceptions
  * [`ArgumentOutOfRangeException`](https://learn.microsoft.com/en-us/dotnet/api/system.argumentoutofrangeexception)
  * [`NullReferenceException`](https://learn.microsoft.com/en-us/dotnet/api/system.nullreferenceexception)
  * [`InvalidOperationException`](https://learn.microsoft.com/en-us/dotnet/api/system.invalidoperationexception)
  * [`HttpRequestException`](https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httprequestexception)



---






## Syntax: Throwing

---

### Overview
* Throw exceptions when there's
  - A problem
  - Nothing you can do about it
* Keyword: [`throw`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#the-throw-statement)
* Guidelines
  - Don't be shy - Exceptions are better than a bad workaround
  - Avoid using for ***expected*** problems
  - Prefer the type system -- Make invalid states unrepresentable

---

### Example 1: Out of Range
* The `throw` statement immediately stops execution
* Supply meaningful error messages and parameter names

```csharp title='OrderLine.cs' {3}
public void SetQuantity(int quantity) {
  if (quantity < 1) {
      throw new ArgumentOutOfRangeException(nameof(quantity), "Quantity must be at least 1.");
  }
  this.Quantity = quantity;
}
```

---

### Example 2: Null

```csharp {7,10}
public class ApiAdapter : IChatCompletionAdapter{
   private readonly ILogger<ApiAdapter> logger;
   private readonly IClientFactory clientFactory;

   public ApiAdapter(IClientFactory factory, ILogger<ApiAdapter> logger){
      // Fail early! Prevent a NullReferenceException later
      if (factory == null)
         throw new ArgumentNullException(nameof(factory));

      if (logger == null)
         throw new ArgumentNullException(nameof(logger));

      //...
   }

```

---

### Example: Empty String

```csharp {7}
public class Person {
    
    public string GivenName{
      get;
      set{
        if(string.IsNullOrWhiteSpace(value)){
          throw new ArgumentException("Name can't be empty.");
        }
        field = value;
      }
    }
}
```

---

### Philosophy: Fail Fast

* **Core Idea**: Identify and report errors as soon as they occur.
* **In Practice**: Check inputs (arguments, state) immediately, as shown in previous examples.
* **Benefit**: Stops invalid data/state from causing complex, hidden bugs later.
* **Avoids**: Problems surfacing far from their origin, making debugging difficult.

---

### Commonly-Thrown Exceptions
* [ArgumentNull](https://learn.microsoft.com/en-us/dotnet/api/system.argumentnullexception) - To avoid null references later on
* [ArgumentOutOfRange](https://learn.microsoft.com/en-us/dotnet/api/system.argumentoutofrangeexception) - When an argument is outside the valid range of values
* [NotImplemented](https://learn.microsoft.com/en-us/dotnet/api/system.notimplementedexception) - Often used to stub-out an implementation that's not done yet
* [InvalidOperation](https://learn.microsoft.com/en-us/dotnet/api/system.invalidoperationexception) - When a method call is invalid in the object's current state
* [FormatException](https://learn.microsoft.com/en-us/dotnet/api/system.formatexception) - When the format of an argument doesn't meet the parameter specifications


---

### Custom Exceptions
* Relatively rare - built-in exceptions usually suffice
* Consider when:
  - For domain-specific error information
  - To catch specific business logic errors
* Common in frameworks and libraries
* Must inherit from [`Exception`](https://learn.microsoft.com/en-us/dotnet/api/system.exception) or its subclasses

---

### Example: Custom Exception

```csharp title='CustomExceptions.cs'
// Define a custom exception class
public class OrderException : Exception {
    public int OrderId { get; }
    
    public OrderException(int orderId, string message) 
        : base(message) {
        OrderId = orderId;
    }
}

```

---

### Throwing Custom Exceptions

```csharp

/// <remarks>Processes an order.</remarks>
/// <exception>
/// Throws an OrderException for cancelled orders.
/// </exception>
public void ProcessOrder(Order order) {
    if (order.Status == OrderStatus.Cancelled) {
        throw new OrderException(order.Id, "Cannot process cancelled orders");
    }
    // Etc.
}
```

---

### Exceptions and Performance
* Exceptions are for exceptional cases, not normal flow
* [Performance impact](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions#performance-considerations) is significant
  - Requires capturing and restoring state
  - BUT you only pay for it when an exception occurs
* Use return values or `out` parameters for expected conditions
* Consider [`TryParse`](https://learn.microsoft.com/en-us/dotnet/api/system.int32.tryparse) pattern for validation



---

### Exception Best Practices

* Only throw for [exceptional conditions](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions), not normal flow
* Choose the [most specific exception type](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/how-to-create-user-defined-exceptions)
* Include detailed information to help diagnose the problem
* Re-throw with `throw;` to preserve the stack trace
* Document exceptions in XML comments with [`<exception>`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc/recommended-tags#exception) tags

---




## Syntax: Catching

---


### Catch Scenarios
1. **When you can do something to remedy the situation** - e.g. retry the operation, or reset to a known state
1. **When you have no remedy, but you want to log or something** 
1. **As a final backstop in your `Main` method** 

---





### Example: Main

```csharp title='Program.cs' {7-10}

public static class Program{

  public static int Main(string[] args){
      try{
          //...
      }
      catch(Exception e){
          Console.WriteLine("An error occurred: " + e.Message);
          return 1;
      }
      return 0;
  }
}

```

---

### Example: Catch a Specific Exception

```csharp {3-6}
public static int Main(string[] args){
  try{/* ... */ }
  catch(FileNotFoundException e){
    Console.WriteLine("File not found. Try again.");
    return 2;
  }
  catch(Exception e){
    Console.WriteLine("An error occurred: " + e.Message);
    return 1;
  }
  return 0;
}

```

---

### Rethrowing

* Rethrow when you need to log, perform partial recovery, or add context
* Use `throw;` to [preserve the original stack trace](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#rethrowing-exceptions)
* Using `throw ex;` resets the stack trace, making debugging harder
* Consider wrapping exceptions (`throw new WrapperException("...", ex);`) to add context
* `throw;` is generally preferred unless wrapping is necessary
---

### Example: Rethrowing

```csharp title='RethrownExceptions.cs'
public void Method1(){
    try {
      throw new ArgumentException("Original error");
    }
    catch (Exception ex) {
        // Bad: Resets stack trace, loses original throw location
        throw ex;
    }
}

public void Method2(){
    try {
        // Some code that might throw
        throw new ArgumentException("Original error");
    }
    catch (Exception) {
        // Good: Preserves full stack trace
        throw;
    }
}
```

---

### Exception Handling Best Practices

* Handle exceptions at the appropriate level in the call stack
* Use specific exceptions for specific errors
* Avoid catching broad exceptions unless absolutely necessary
* Use `finally` to clean up resources
* Document exceptions in XML comments with `<exception>` tags

---

### Alternative Take: Gotta Catch 'Em All
* From [Eric Lippert](https://ericlippert.com/2014/03/06/living-with-unchecked-exceptions-part-two/):
> I think the whole notion of "handling" exceptions is a bit of a fool's game. I can probably 
> count on the fingers of one hand the times where I've been able to catch a specific exception
> and then do something intelligent with it. 99% of the time you should either catch everything 
> or catch nothing. When an exception of any type occurs, rewind to a stable state and then 
> either abort or continue.


---



## Syntax: Finally

---

### Overview
* Keyword: [`finally`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#the-finally-block)
* Always executes, even if an exception occurs
* Perfect for cleanup: closing files, releasing resources
* Cannot use `return`, `break`, or `continue` in `finally`
* Consider using [`using`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/using) for `IDisposable` resources

---

### Example: Finally

```csharp title="ResourceCleanup.cs"
public void ProcessFile(string path) {
    FileStream? file = null;
    try {
        file = File.OpenRead(path);
        // Process the file
    }
    catch (FileNotFoundException) {
        Console.WriteLine("File not found");
    }
    finally {
        // Always runs, even if an exception occurs
        file?.Dispose();
        // BTW, `using` is a better construct and it's coming 
        // up next
    }
}

```

---




## Fin

---

### Review

1. Explain when to throw exceptions versus using return values
2. Describe the difference between `throw` and `throw ex`
3. List three common exception types and when to use them
4. Explain why catching `Exception` is generally discouraged
5. Describe the purpose of the `finally` block
