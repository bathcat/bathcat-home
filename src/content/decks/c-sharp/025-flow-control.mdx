---
title: "Flow Control"
description: "Flow control mechanisms, from basic conditionals and loops to modern pattern matching features."
status: 'Live'
flavor: 'Deck'
---

# Flow Control

---

### Goals

1. Lorem
2. Ipsum
3. Sic

---




## Conditionals

---

### Overview
* [`?:` operator](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator) for simple if/else expressions
* [`if`/`else`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/selection-statements#the-if-statement) for basic branching
* [`switch`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/selection-statements#the-switch-statement) for multiple conditions
* Modern C# features:
  - [Pattern matching](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching) in `if` and `switch`
  - [Switch expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression)
  - [Null checks](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#logical-patterns) with `is` and `is not`

---

### Ternary Operator
* Expression form of if/else: `condition ? trueValue : falseValue`
* Can be used in assignments, method arguments, etc.
* Example:
```csharp
public string ToStatus(bool isActive)
    => isActive ? "Online" : "Offline";

// Can be used directly in string interpolation
Console.WriteLine($"User is {user.IsActive ? "online" : "offline"}");
```

---

### `if`/`else`

```csharp
public string GetGreeting(int hour){
    if (hour < 0 || hour > 23)
        throw new ArgumentException("Hour must be between 0 and 23");

    if (hour < 12)
        return "Good morning!";
    else if (hour < 17)
        return "Good afternoon!";
    else if (hour < 22)
        return "Good evening!";
    else
        return "Good night!";
}
```

---

### Notes on If / Else
* Extract complex conditions into [well-named methods](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-style-guidelines#naming-guidelines)
* Avoid [arrow anti-pattern](https://blog.codinghorror.com/flattening-arrow-code/) with early returns
* Keep nesting shallow - prefer [guard clauses](https://refactoring.guru/replace-nested-conditional-with-guard-clauses)
* Consider [pattern matching](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching) for complex conditions

---

### `switch`
* Traditional [switch statement](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/selection-statements#the-switch-statement) for multiple conditions
* Modern [switch expression](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression) for value selection
* Supports [pattern matching](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#switch-expression) with `when` clauses
* Can match on [type patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#type-patterns) and [property patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#property-pattern)
* `default` case handles unmatched values

---

### Example, Old School

```csharp
public string GetDayName(int day){
    switch (day){
        case 1: return "Monday";
        case 2: return "Tuesday";
        case 3: return "Wednesday";
        case 4: return "Thursday";
        case 5: return "Friday";
        case 6: return "Saturday";
        case 7: return "Sunday";
        default: throw new ArgumentException("Day must be between 1 and 7");
    }
}
```

---

### Example #2

```csharp
public string GetPeriod(int quarter) {
    string period;
    switch (quarter) {
        case 1:
            period = "Early";
            break;
        case 2: // fall through
        case 3:
            period = "Mid";
            break;
        default:
            period = "Late";
            break;
    }
    return period;
}
```

---



## Comparisons

---

### Overview
* Things usually work as expected
* Equality is sometimes tricky


---

### Comparison Operators

| Op | Description | Example |
|----------|:-------------|:---------|
| `==` | [Equals ](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators#equality-operator-) | `if (x == y)` |
| `!=` | [Not equals](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators#inequality-operator-) | `if (x != y)` |
| `<` | [Less than](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/comparison-operators#less-than-operator-) | `if (x < y)` |
| `>` | [Greater than](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/comparison-operators#greater-than-operator-) | `if (x > y)` |
| `<=` | [Less than or equal](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/comparison-operators#less-than-or-equal-operator-) | `if (x <= y)` |
| `>=` | [Greater than or equal](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/comparison-operators#greater-than-or-equal-operator-)) | `if (x >= y)` |


---

### Type Checking
| Op | Description | Example |
|----------|:-------------|---------|
| `is` | Tests if object is compatible with a type ([docs](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#is-operator)) | `if (obj is string)` |
| `is not` | Tests if object is _not_ compatible with a type ([docs](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#logical-patterns)) | `if (obj is not null)` |

---

### Equality

* **Value types**: Use [structural equality](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/equality-comparisons) (comparing actual values)
* **Reference types**: Use [reference equality](https://learn.microsoft.com/en-us/dotnet/api/system.object.referenceequals) (comparing memory addresses)
* **Customizable**: Override [`Equals`](https://learn.microsoft.com/en-us/dotnet/api/system.object.equals) and [`GetHashCode`](https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode)
* **Consistency**: Always implement [`IEquatable<T>`](https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1) when customizing
* **Verification**: [Unit tests](https://learn.microsoft.com/en-us/dotnet/core/testing/) help verify equality behavior works as expected


---

### Examples

```csharp
var equals0 = "Hello" == "hello"; // false
var equals1 = String.Equals("Hello", "Hello", StringComparison.OrdinalIgnoreCase); // true

var list1 = new List<int> { 1, 2, 3 };
var list2 = new List<int> { 1, 2, 3 };
var equals2 = list1 == list2; // false
var equals3 = Enumerable.SequenceEqual(list1, list2); // true

var point1 = new Point(1, 2);
var point2 = new Point(1, 2);
var equals4 = point1 == point2; // ???
```


---

### Handy Methods

* **[Object.ReferenceEquals](https://learn.microsoft.com/en-us/dotnet/api/system.object.referenceequals)**: Checks if two references point to same object
* **[Enumerable.SequenceEqual](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.sequenceequal)**: Compares collections element by element
* **[String.IsNullOrEmpty](https://learn.microsoft.com/en-us/dotnet/api/system.string.isnullorempty)**: Checks if string is null or empty
* **[String.Equals](https://learn.microsoft.com/en-us/dotnet/api/system.string.equals)**: Compares strings with optional case insensitivity

---

### More to Come
* There's a lot more to say.
* Modern C# includes:
  - [Pattern matching](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching)
  - [Null-related operators](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#logical-patterns) with `is` and `is not`

---




## Loops

---

### Overview

* [`for`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement) for counting and index-based iteration
* [`foreach`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement) for collection traversal
* [`while`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-while-statement) and [`do-while`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-do-statement) for condition-based loops
* Modern alternatives:
  - [LINQ](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/) for collection operations
  - [Functional programming](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/) with map/reduce

---

### `for` loop
* Works exactly as you'd expect
* Use when you need:
  - Index-based access
  - Counting or sequence generation
  - Multiple loop variables
* Prefer `foreach` for collection traversal


---

### Example: For Loop

```csharp title='ArrayProcessor.cs'
public int Sum(int[] numbers) {
    int sum = 0;
    for (int i = 0; i<numbers.Length; i++) {
        sum += numbers[i];
    }
    return sum;
}
```

---

### `foreach` loop
* Use when you need:
  - Collection traversal
  - Read-only access to elements
  - Clean, declarative syntax
* Prefer `for` when index is needed

---

### Example: Foreach Loop

```csharp title='CollectionProcessor.cs'
public int Sum(IEnumerable<int> numbers) {
    var sum = 0;
    foreach (var num in numbers) {
        if (num > 0) sum += num;
    }
    return sum;
}
```


---

### While Loop
* Use when you need:
  - Complex termination conditions
  - External state changes
  - Infinite loops with breaks
* Prefer `for` for counting, `foreach` for collections

---

### Example: While Loop
```csharp title='StreamProcessor.cs'
public string ReadUntilEnd(StreamReader reader) {
    var result = new StringBuilder();
    while (!reader.EndOfStream) {
        result.Append(reader.ReadLine());
    }
    return result.ToString();
}
```

---

### Break and Continue

* [`break`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/jump-statements#the-break-statement) exits the nearest enclosing loop
* [`continue`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/jump-statements#the-continue-statement) skips to next iteration
* Common use cases:
  - Early loop termination
  - Skipping invalid items
  - Infinite loops with conditions
* Prefer early `return` over `break` when possible

---

### Example: Break
```csharp title='BreakExample.cs'
public void ProcessItems(IEnumerable<Item> items) {
    foreach (var item in items) {
        if (item.IsInvalid) {
            break;  // Stop processing on first invalid item
        }
        ProcessItem(item);
    }
}
```

---

### Example: Continue
```csharp title='ContinueExample.cs'
public int SumValidNumbers(IEnumerable<string> inputs) {
    var sum = 0;
    foreach (var input in inputs) {
        if (!int.TryParse(input, out var number)) {
            continue;  // Skip invalid inputs
        }
        sum += number;
    }
    return sum;
}
```

---

### Loop Alternatives

* **Functional approaches** replace explicit loops with higher-order functions
* e.g. `Select`, `Where`, `Aggregate`
* **Benefits**:
  - Declarative - i.e. what to do, not how
  - Concise, readable
  - Easier to test in isolation
* [LINQ](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/) brings these patterns to C# with a SQL-like syntax
