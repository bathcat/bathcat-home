---
title: "Async"
description: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla dapibus consectetur nisl, non ultrices metus pulvinar ut. Nullam hendrerit, magna et congue ullamcorper, mauris risus pulvinar ante, quis consequat mi sapien porttitor massa."
status: 'Draft'
flavor: 'Deck'
---




# Async

---

### Goals

1. Lorem
2. Ipsum
3. Sic

---





## Asynchrony

---


### What's 'Blocking' IO?

* Operations that pause thread execution until completed
* **Examples:** network requests, file operations, database queries
* **Problems**
  - Consumes a [thread pool thread](https://learn.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool) unnecessarily
  - Can lead to [thread pool starvation](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/debug-threadpool-starvation)
  - In UI applications, blocking the main thread freezes the interface
* **Modern alternative:** [asynchronous programming](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/) with Tasks

---

### Parallelism v Asynchrony

- Parallelism spreads work across multiple CPUs
  - But thread might be blocked by IO operations
- Asyc is non-blocking

---

### [Async Patterns](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/)

- Old-School
  - Asynchronous Programming Model aka begin/end
  - Callbacks
  - Event-based
- Task-based - aka promises

---

### Task-Based Parallelism

- A Task represents the eventual result of an async operation
  1. Completion, optional return value
  2. Error
- Similar to a `Promise` in other languages

---

### Example: Food Hall, Blocking

```csharp
static void Main(string[] args)
{
    Coffee coffee = PourCoffee();
    Console.WriteLine("coffee is ready");

    Beer[] beers= PourBeer(2);
    Console.WriteLine("Beers poured!");

    Burrito[] burritos = MakeBurritos(2);
    Console.WriteLine("Burritos ready");

    Burger burger = MakeBurger();
    ApplyCondiments(burger);

    Console.WriteLine("Hipster dinner served!");
}
```

---

### Example: Food Hall, Async

```csharp
static async Task void Main(string[] args)
{
    Coffee coffee = PourCoffee();
    Console.WriteLine("coffee is ready");

    Beer[] beers= await PourBeer(2);
    Console.WriteLine("Beers poured!");

    Burrito[] burritos = await MakeBurritos(2);
    Console.WriteLine("Burritos ready");

    Burger burger = await MakeBurger();
    ApplyCondiments(burger);

    Console.WriteLine("Hipster dinner served!");
}
```

---

### Things to Notice

- Everything still happens sequentially
- Keyword `async` on the method
- `Task` returned
- Keyword `await` is magical transparent callback!

---

### Example: Food Hall, Parallel

```csharp
static async Task void Main(string[] args)
{
    Coffee coffee = PourCoffee();
    Console.WriteLine("coffee is ready");

    Task<Beer[]> beersTask= PourBeer(2);
    Console.WriteLine("Beers poured!");

    Task<Burrito[]> burritosTask = MakeBurritos(2);
    Console.WriteLine("Burritos ready");

    Burger burger = await MakeBurger();
    ApplyCondiments(burger);

    Beer[] beers = await beersTask;
    Burrito[] burritos = await burritosTask;

    Console.WriteLine("Hipster dinner served!");
}
```

---

### What's the Point?

- Free up threads to do useful work
- Used for IO-intensive things:
  - Network
  - Disc
  - Databases
- **Not** for CPU-intensive operations

---

### Red v Blue
#### Seminal article: [What Color is Your Function?](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)
1. Every function has a color
2. The way you call the function depends on its color
3. You can only call a red function from within another red function
4. Red functions are more painful to call
5. Some core library functions are red

---

### The Case of Node.js
* **Question:** How is it that JavaScript is slow, but [Node.js](https://nodejs.org/en/) is fast
* **Answer:** Non-blocking I/O!
* Background:
  - JavaScript is single-threaded
  - Node.js uses an event-driven, non-blocking I/O model
* Successful because:
  - IO takes up most of the time
  - Blocked threads are expensive

---





## Tasks

---

### Overview
* [Task](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task) represents an asynchronous operation
  - Also known as a Promise or Future
  - Can succeed or fail
  - Can return a value or void
* Tasks are composable
  - Can chain operations
  - Can run in parallel
  - Can be `await`ed
* Tasks are cancellable
  - Support cancellation tokens
  - Can be timed out

---

### Blocking

```csharp
public class Program{
    private static void Block(int timeoutInMS)
        => Thread.Sleep(timeoutInMS);

    public static void Main(string[] args){
        Console.WriteLine($"Waiting for {5000}ms...");
        Block(5000);
        Console.WriteLine("Done");
    }
}
```

---

### Non-Blocking

```csharp
public class Program{
  private static Task Delay(int timeoutInMS) // <-- Task
      => Task.Delay(timeoutInMS); // <-- Task.Delay (non-blocking)

  public static async Task Main(){// <-- `async` + Task  
       Console.WriteLine($"Waiting for {5000}ms...");
       await Delay(5000);  //  <-- `await`
       Console.WriteLine("Done");
  }
}
```

---

### Recipe
#### To make a method non-blocking
* **Required**
  - Return a `Task` instead of `void`
  - OR return a `Task<T>` instead of `T`
* **Optional**
  - Use `async` to if you need to await something
  - Use `await` to await

---

### Example: `IsUp` Blocking

```csharp
public static bool IsUp(string url){
    using var client = new WebClient();
    try{
        var s = client.DownloadString(url);
        return !String.IsNullOrWhiteSpace(s);
    }
    catch (WebException) {return false;}    
}
public static void Run(string[] args){
    Console.WriteLine("Is Google Up?");
    var isUp = IsUp("https://www.google.com");
    Console.WriteLine(isUp ? "Yes" : "No");
}

```

---

### Example: `IsUp` Non-Blocking

```csharp
public static async Task<bool> IsUpAsync(string url){
    using var client = new WebClient();
    try{
        var s = await client.DownloadStringTaskAsync(url);
        return !String.IsNullOrWhiteSpace(s);
    }
    catch (WebException){return false;}    
}

public static async Task RunAsync(string[] args){
    Console.WriteLine("Is Google Up?");
    var isUp = await IsUpAsync("https://www.google.com");
    Console.WriteLine(isUp ? "Yes" : "No");
}
```

---

### Example: IsUp, HttpClient

```csharp
// Create as a singleton/static instance for better performance
private static readonly HttpClient _client = new HttpClient();

public static async Task<bool> IsUpAsync(string url){
    try{
        var response = await _client.GetAsync(url);
        
        // EnsureSuccessStatusCode throws if not 2xx status
        response.EnsureSuccessStatusCode();
        return true;
    }
    catch (HttpRequestException){}
    return false;
}

public static async Task RunAsync(){
    Console.WriteLine("Is Google Up?");
    var isUp = await IsUpAsync("https://www.google.com");
    Console.WriteLine(isUp ? "Yes" : "No");
}
```


---



## Recipes

---

### Overview
* Usually you'll be using Tasks from libraries
* Create your own when you need to
  - Fake async operations
  - Wrap blocking APIs
  - Unblock UI threads

---


### Recipe: Fake Async
* [Task.Delay](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.delay) is the non-blocking equivalent of Thread.Sleep
* Doesn't tie up thread pool threads while waiting
* Returns a [Task](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task) that completes after specified time


```csharp
public static async Task FakeAsync(){
    await Task.Delay(1000);
}
```

---

### Recipe: Wrap Blocking APIs

