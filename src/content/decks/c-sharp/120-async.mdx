---
title: "Async"
description: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla dapibus consectetur nisl, non ultrices metus pulvinar ut. Nullam hendrerit, magna et congue ullamcorper, mauris risus pulvinar ante, quis consequat mi sapien porttitor massa."
status: 'Live'
flavor: 'Deck'
---




# Async

---

### Goals

1. Name the problem with blocking IO
2. Explain the distinction between parallelism and asynchrony
3. Give the recipe for turning a blocking method into an async method
4. Name 2 patterns for composing async operations

---

### Roadmap

1. Overview
2. Rules and Recipes
3. Composition

---




## Overview

---

### IO is ***the*** Bottleneck

* Most business apps wait for **I/O**, not CPU calculations.
* **I/O-Bound**: Waiting for 
  - [File Access](https://learn.microsoft.com/en-us/dotnet/standard/io/)
  - Network
  - [Database](https://learn.microsoft.com/en-us/ef/core/).
* **CPU-Bound**: Limited by processor speed (less common in typical apps).
* Async avoids blocking threads during these I/O waits.


---

### What's 'Blocking' IO?

* Operations that pause thread execution until completed
* **Problems**
  - Consumes a [thread pool thread](https://learn.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool) unnecessarily
  - Can lead to [thread pool starvation](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/debug-threadpool-starvation)
  - In UI applications, blocking the main thread freezes the interface
* **Modern alternative:** [asynchronous programming](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/) with Tasks

---

### Blocking Examples
```csharp title='Blocking I/O Examples'
// Example of blocking file read
Console.WriteLine("Reading file...");
string fileContent = File.ReadAllText("example.txt"); // Blocks thread
Console.WriteLine($"Read {fileContent.Length} characters.");

// Example of blocking network request (requires System.Net using)
using var client = new System.Net.WebClient();
Console.WriteLine("Downloading web page...");
string pageContent = client.DownloadString("http://example.com"); // Blocks thread
Console.WriteLine($"Downloaded {pageContent.Length} characters.");
```

---

### What's the Problem?
* Waiting _seems_ passive, but the **thread is still occupied**.
* Threads are managed a [pool](https://learn.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool).
  - The number of threads is limited
  - Blocked threads **cannot do other work**
  - Too many blocked threads can lead to **[Thread Pool Starvation](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/debug-threadpool-starvation)**, harming performance.
* In UI apps, blocking the main thread **freezes the user interface**.

---

### Parallelism vs. Asynchrony

* **Often confused, but _distinct_ concepts.**
* **[Parallelism](https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl)**: Do multiple things *at the same time*
   - Often complex (race conditions, deadlocks).
* **[Asynchrony](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/)**: Begin work, let it run *without blocking* the current thread.
  - Frees threads during I/O waits, **saving resources** even on one CPU.
  - Often still be sequential
* **Our Focus**: **Asynchrony**

---

### [Async Patterns](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/)

* Older Patterns (mostly legacy):
  - [APM (Asynchronous Programming Model)](https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm) - `BeginXXX`/`EndXXX` methods.
  - [EAP (Event-based Asynchronous Pattern)](https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap) - `XXXAsync` methods + `XXXCompleted` events.
* **Modern Standard**: [TAP (Task-based Asynchronous Pattern)](https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)
  - Uses `Task` and `Task<TResult>`.
  - Foundation for `async`/`await` keywords.

---

### Tasks: The Core of Modern C# Async

* **Definition:** A [`Task`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task) represents an asynchronous operation that will complete in the future.
* Resolves:
  - Successfully, often with a `TResult`
  - With an error
* Similar concept to a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) in JavaScript.

---

### Example: Food Hall, Blocking

```csharp
static void Main(string[] args){
    Coffee coffee = PourCoffee();
    Console.WriteLine("coffee is ready");

    Beer[] beers= PourBeer(2); // <-- Blocking
    Console.WriteLine("Beers poured!");

    Burrito[] burritos = MakeBurritos(2); // <-- Blocking
    Console.WriteLine("Burritos ready");

    Burger burger = MakeBurger(); // <-- Blocking
    ApplyCondiments(burger);

    Console.WriteLine("Hipster dinner served!");
}
```

---

### Example: Food Hall, Async

```csharp
static async Task void Main(string[] args){
    Coffee coffee = PourCoffee();
    Console.WriteLine("coffee is ready");

    Beer[] beers= await PourBeerAsync(2);
    Console.WriteLine("Beers poured!");

    Burrito[] burritos = await MakeBurritosAsync(2);
    Console.WriteLine("Burritos ready");

    Burger burger = await MakeBurgerAsync();
    ApplyCondiments(burger);

    Console.WriteLine("Hipster dinner served!");
}
```

---

### Things to Notice

* **Still sequential:** Each `await` finishes before the next line starts.
* Methods return `Task`, `Task<T>`, or `void` (avoid `async void`).
* Keywords:
  - [`async`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/async) enables `await`.
  - [`await`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/await) pauses the method, frees the thread, resumes when `Task` completes.
* **Benefit**: Thread isn't blocked during I/O waits (like getting food/drinks).

---


### Example: Food Hall, Parallel

```csharp
static async Task void Main(string[] args){
    Coffee coffee = PourCoffee();
    Console.WriteLine("coffee is ready");

    // Get these tasks started and move on
    Task<Beer[]> beersTask= PourBeerAsync(2);
    Task<Burrito[]> burritosTask = MakeBurritosAsync(2);

    // Wait for the burger because we need to apply condiments
    Burger burger = await MakeBurger();
    ApplyCondiments(burger);

    // Now wait for dinner
    Beer[] beers = await beersTask;
    Console.WriteLine("Beers poured!");

    Burrito[] burritos = await burritosTask;
    Console.WriteLine("Burritos ready");

    Console.WriteLine("Hipster dinner served!");
}
```

---

### Things to Notice

* **Concurrency Achieved**: Beer and burrito prep started concurrently.
* **Tasks are Awaitable Later**: `Task` objects were stored and `await`ed when the result was needed.
* **Logical Order Still Matters**: Some steps are inherently sequential (make burger *then* add condiments).
* **Efficiency**: While waiting for beers/burritos, the burger prep could happen.

---



## Rules and Recipes

---

### Red v Blue
#### Seminal article: [What Color is Your Function?](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)
1. Every function has a color
2. The way you call the function depends on its color
3. You can only call a red function from within another red function
4. Red functions are more painful to call
5. Some core library functions are red

---

### Rules

* **Rule #1:** [`await`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/await) keyword is **only** valid inside a method marked with [`async`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/async)
* **"Async Grows"**: 
  - If you need to `await` something, your method must become `async`.
  - This often causes `async` to spread up through your call stack.
* **Sync-over-Async (Use with Caution!)**: 
  - Calling `async` from sync code (e.g., `.Result`, `.GetAwaiter().GetResult()`) can cause [deadlocks](https://learn.microsoft.com/en-us/archive/blogs/ptorr/await-and-ui-and-deadlocks-oh-my), especially in UI/ASP.NET.
  - Prefer making the caller `async` all the way up.

---

### Example
```csharp title='Error: await requires async method'
using System.IO;
using System.Threading.Tasks;

public class Program {
    // This Main method is NOT async
    static void Main(string[] args) {
        // COMPILER ERROR CS4033: The 'await' operator can only be used
        // within an async method. Mark Main as 'async Task'.
        string content = await File.ReadAllTextAsync("example.txt"); 
        Console.WriteLine($"Read: {content.Length} chars");
    }
}
```

---

### Fixed

```csharp {6}
using System.IO;
using System.Threading.Tasks;

public class Program {
    // This Main method is NOW async!
    static async Task Main(string[] args) {


        string content = await File.ReadAllTextAsync("example.txt"); 
        Console.WriteLine($"Read: {content.Length} chars");
    }
}
```

---

### Recipe
#### To make a method non-blocking
* **Required**
  - Return a `Task` instead of `void`
  - Return a `Task<T>` instead of `T`
* **Optional**
  - Use `async` to if you need to await something
  - Use `await` to await

---

### Async is Optional


```csharp
public static async Task<string> GetTextWithAsyncKeyword(string path){
    return await File.ReadAllTextAsync(path);
}

public static Taks<string> GetTextWithoutAsyncKeyword(string path){
    return File.ReadAllTextAsync(path);
}

```

* `async` is **only required** if you use `await` inside the method body.
* If a method just returns a `Task` from another async call, `async`/`await` is optional.
* Both methods are equivalent.

---

### Example 2: `IsUp` (Blocking)

```csharp
public static bool IsUp(string url){
    using var client = new WebClient();
    try{
        var s = client.DownloadString(url);
        return !String.IsNullOrWhiteSpace(s);
    }
    catch (WebException) {return false;}    
}
public static void Run(string[] args){
    Console.WriteLine("Is Google Up?");
    var isUp = IsUp("https://www.google.com");
    Console.WriteLine(isUp ? "Yes" : "No");
}

```
---


### Example: `IsUp` (Async)

```csharp
public static async Task<bool> IsUpAsync(string url){
    using var client = new WebClient();
    try{
        var s = await client.DownloadStringTaskAsync(url);
        return !String.IsNullOrWhiteSpace(s);
    }
    catch (WebException){return false;}    
}

public static async Task RunAsync(string[] args){
    Console.WriteLine("Is Google Up?");
    var isUp = await IsUpAsync("https://www.google.com");
    Console.WriteLine(isUp ? "Yes" : "No");
}
```

---

### Aside: WebClient vs HttpClient

* The examples used [`WebClient`](https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient) because it has both sync (`DownloadString`) and async (`DownloadStringTaskAsync`) methods.
* However, `WebClient` is **legacy** and not recommended for new development.
* The modern way is [`HttpClient`](https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient).
  - **Only provides async methods** for network I/O, encouraging the non-blocking pattern.

---

### Example: IsUp, HttpClient

```csharp
// Create as a singleton/static instance for better performance
private static readonly HttpClient _client = new HttpClient();

public static async Task<bool> IsUpAsync(string url){
    try{
        var response = await _client.GetAsync(url);
        
        // EnsureSuccessStatusCode throws if not 2xx status
        response.EnsureSuccessStatusCode();
        return true;
    }
    catch (HttpRequestException){}
    return false;
}

public static async Task RunAsync(){
    Console.WriteLine("Is Google Up?");
    var isUp = await IsUpAsync("https://www.google.com");
    Console.WriteLine(isUp ? "Yes" : "No");
}
```

---



## Composition

---

### Overview

* Often, you just need to `await` a single `Task`.
* But `Task` objects can be combined for more complex scenarios.
* Common patterns: Run multiple tasks concurrently and... 
  * Wait for all: [`Task.WhenAll`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.whenall)
  * Wait for the first one to finish: [`Task.WhenAny`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.whenany)
* Allows for efficient parallel execution of independent async operations.

---

### WhenAll

* Use [`Task.WhenAll`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.whenall) to wait for multiple `Task`s to complete.
* Creates a new `Task` that finishes only after *all* the tasks you provided are done.
* **Scenario:** Start multiple independent operations concurrently.
  * Example: Order beers *and* make burritos at the same time.
  * Example: Fetch data from several different web APIs simultaneously.
* **Benefit:** Wait time is dictated by the *longest* operation, not the sum of all.
* Returns results (if tasks are `Task<T>`) once all are complete.

---

### Example: WhenAll

```csharp title='Waiting for Food Hall Orders'
// Start both orders concurrently
Task<Beer[]> beerTask = PourBeerAsync(2);
Task<Burrito[]> burritoTask = MakeBurritosAsync(2);

// Wait for BOTH tasks to complete
await Task.WhenAll(beerTask, burritoTask);

// Now we can safely access the results
Beer[] beers = await beerTask;
Burrito[] burritos = await burritoTask;

Console.WriteLine("Beers and burritos are ready!");
```

---

### WhenAny

* [`Task.WhenAny`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.whenany) creates a new `Task` that finishes when *any* of the tasks you provided are done.
* **Example:** Fire up multiple API requests and return the first result
* **Benefit:** Wait time is dictated by the *shortest* operation, not the sum of all.

---

### Example: WhenAny

```csharp title='Getting the Fastest Animal Fact'
// Assume GetCatFactAsync() and GetDogFactAsync() exist
Console.WriteLine("Fetching animal facts...");

// Start both API calls concurrently
Task<string> catFactTask = GetCatFactAsync(); 
Task<string> dogFactTask = GetDogFactAsync();

// Wait for ANY task to complete
Task<string> firstCompletedTask = await Task.WhenAny(catFactTask, dogFactTask);

// Get the result from the task that finished first
string fact = await firstCompletedTask;

Console.WriteLine($"First fact received: {fact}");
```

---


## Fin

---

### Review

1. Name the problem with blocking IO
2. Explain the distinction between parallelism and asynchrony
3. Give the recipe for turning a blocking method into an async method
4. Name 2 patterns for composing async operations
