---
title: "Collections"
description: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla dapibus consectetur nisl, non ultrices metus pulvinar ut. Nullam hendrerit, magna et congue ullamcorper, mauris risus pulvinar ante, quis consequat mi sapien porttitor massa."
status: 'Draft'
flavor: 'Deck'
---

# Collections

---

### Goals

1. Lorem
2. Ipsum
3. Sic

---


## Enumerable

---

### Overview
* Foundation of C# collection iteration
* Central to LINQ operations
* Represents a sequence of elements
* Returns an iterator (IEnumerator)
* Enables foreach statement on collections

---

### Pattern: [Iterator](https://en.wikipedia.org/wiki/Iterator_pattern) 
* Provides sequential access to elements
* Hides collection's internal structure
* Separates traversal from collection implementation
* Enables multiple traversals simultaneously
* Core pattern in .NET Framework design

---

### Interface Definition

```csharp
// The IEnumerable generic interface
public interface IEnumerable<out T> : IEnumerable{
    IEnumerator<T> GetEnumerator();
}

// The non-generic version
public interface IEnumerable{
    IEnumerator GetEnumerator();
}
```

---

### Using IEnumerable

```csharp
// Built-in collections implement IEnumerable
List<int> numbers = new List<int> { 1, 2, 3 };

// Using foreach (requires IEnumerable)
foreach (int num in numbers){
    Console.WriteLine(num);
}

// Manual iteration
IEnumerator<int> enumerator = numbers.GetEnumerator();
while (enumerator.MoveNext()){
    Console.WriteLine(enumerator.Current);
}
```

---

### LINQ with IEnumerable

```csharp
IEnumerable<int> numbers = Enumerable.Range(1, 10);

// Query syntax
var query = from n in numbers
            where n % 2 == 0
            select n * n;

// Method syntax
var method = numbers.Where(n => n % 2 == 0)
                    .Select(n => n * n);
```

---

### Implementing IEnumerable

```csharp
public class MyCollection<T> : IEnumerable<T>{
    private List<T> items = new List<T>();
    
    public IEnumerator<T> GetEnumerator(){
        return items.GetEnumerator();
    }
    
    IEnumerator IEnumerable.GetEnumerator(){
        return GetEnumerator();
    }
}
```

---

### Extension Methods Defined
* Static methods that extend existing types
* Introduced in C# 3.0
* Declared with "this" parameter modifier
* [LINQ](https://learn.microsoft.com/en-us/dotnet/csharp/linq/) is built on extension methods
* Extend types without modifying original source code

---

### Extension Methods Example

```csharp
// Extension method for any IEnumerable<T>
public static class EnumerableExtensions{
    public static T ForEach<T>(this IEnumerable<T> source, Action<T> action){
        foreach (T item in source){
            action(item);
        }
    }
}

// Usage
List<int> numbers = new List<int> { 1, 2, 3 };
numbers.ForEach(n => Console.WriteLine(n));
```

---

### Greatest Hits
* [Select](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.select) - Aka 'map' transforms each element
* [Where](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.where) - Shrinks the collection to match a predicate
* [OrderBy](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.orderby) - Sorts elements 
* [FirstOrDefault](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault) - Returns first element or default
* [GroupBy](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.groupby) - Groups elements by specified key
* [Aggregate](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.aggregate) - Applies accumulator function over sequence

---

### Query Syntax vs Method Syntax

```csharp
// Query syntax - SQL-like
var queryJoin = from c in customers
               join o in orders on c.ID equals o.CustomerID
               select new { c.Name, o.OrderDate };

// Method syntax - Fluent API style
var methodChain = customers
    .Where(c => c.IsActive)
    .Select(c => c.Name);
```

---

### Query Syntax vs Method Syntax
* Most developers prefer [method syntax](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq)
* Query syntax is more readable for [complex joins](https://learn.microsoft.com/en-us/dotnet/csharp/linq/join-operations)
* Both compile to the same IL code
* Can mix styles in the same query
* Method syntax exposes more operations

---

### LINQ and Deferred Execution

```csharp
// Define query - nothing executes yet
var query = numbers
    .Where(n => { Console.WriteLine($"Filtering {n}"); return n > 5; })
    .Select(n => { Console.WriteLine($"Mapping {n}"); return n * 2; });

// Only executes when data is needed
Console.WriteLine("About to execute query");
foreach (var item in query) // Execution happens here
{
    Console.WriteLine($"Result: {item}");
}
```

* LINQ uses [deferred execution](https://learn.microsoft.com/en-us/dotnet/standard/linq/deferred-execution-example)
* Operations chain like a [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming))
* Query builds an expression pipeline
* Execution only happens when enumerated
* Allows efficient processing of large datasets

---



