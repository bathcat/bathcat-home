---
title: "Collections"
description: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla dapibus consectetur nisl, non ultrices metus pulvinar ut. Nullam hendrerit, magna et congue ullamcorper, mauris risus pulvinar ante, quis consequat mi sapien porttitor massa."
status: 'Live'
flavor: 'Deck'
---

# Collections

---

### Goals

1. Lorem
2. Ipsum
3. Sic

---


## Enumerable

---

### Overview
* Foundation of C# collection iteration
* Central to LINQ operations
* Represents a sequence of elements
* Returns an iterator (IEnumerator)
* Enables foreach statement on collections

---

### Pattern: [Iterator](https://en.wikipedia.org/wiki/Iterator_pattern) 
* Provides sequential access to elements
* Hides collection's internal structure
* Separates traversal from collection implementation
* Enables multiple traversals simultaneously
* Core pattern in .NET Framework design

---

### Interface Definition

```csharp
// The IEnumerable generic interface
public interface IEnumerable<out T> : IEnumerable{
    IEnumerator<T> GetEnumerator();
}

// The non-generic version
public interface IEnumerable{
    IEnumerator GetEnumerator();
}
```

---

### Using IEnumerable

```csharp
// Built-in collections implement IEnumerable
List<int> numbers = new List<int> { 1, 2, 3 };

// Using foreach (requires IEnumerable)
foreach (int num in numbers){
    Console.WriteLine(num);
}

// Manual iteration
IEnumerator<int> enumerator = numbers.GetEnumerator();
while (enumerator.MoveNext()){
    Console.WriteLine(enumerator.Current);
}
```

---

### LINQ with IEnumerable

```csharp
IEnumerable<int> numbers = Enumerable.Range(1, 10);

// Query syntax
var query = from n in numbers
            where n % 2 == 0
            select n * n;

// Method syntax
var method = numbers.Where(n => n % 2 == 0)
                    .Select(n => n * n);
```

---

### Implementing IEnumerable

```csharp
public class MyCollection<T> : IEnumerable<T>{
    private List<T> items = new List<T>();
    
    public IEnumerator<T> GetEnumerator(){
        return items.GetEnumerator();
    }
    
    IEnumerator IEnumerable.GetEnumerator(){
        return GetEnumerator();
    }
}
```

---

### Extension Methods Defined
* Static methods that extend existing types
* Introduced in C# 3.0
* Declared with "this" parameter modifier
* [LINQ](https://learn.microsoft.com/en-us/dotnet/csharp/linq/) is built on extension methods
* Extend types without modifying original source code

---

### Extension Methods Example

```csharp
// Extension method for any IEnumerable<T>
public static class EnumerableExtensions{
    public static T ForEach<T>(this IEnumerable<T> source, Action<T> action){
        foreach (T item in source){
            action(item);
        }
    }
}

// Usage
List<int> numbers = new List<int> { 1, 2, 3 };
numbers.ForEach(n => Console.WriteLine(n));
```

---

### Greatest Hits
* [Select](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.select) - Aka 'map' transforms each element
* [Where](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.where) - Shrinks the collection to match a predicate
* [OrderBy](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.orderby) - Sorts elements 
* [FirstOrDefault](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault) - Returns first element or default
* [GroupBy](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.groupby) - Groups elements by specified key
* [Aggregate](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.aggregate) - Applies accumulator function over sequence

---

### Query Syntax vs Method Syntax

```csharp
// Query syntax - SQL-like
var queryJoin = from c in customers
               join o in orders on c.ID equals o.CustomerID
               select new { c.Name, o.OrderDate };

// Method syntax - Fluent API style
var methodChain = customers
    .Where(c => c.IsActive)
    .Select(c => c.Name);
```

---

### Query Syntax vs Method Syntax
* Most developers prefer [method syntax](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq)
* Query syntax is more readable for [complex joins](https://learn.microsoft.com/en-us/dotnet/csharp/linq/join-operations)
* Both compile to the same IL code
* Can mix styles in the same query
* Method syntax exposes more operations

---

### LINQ and Deferred Execution

```csharp
// Define query - nothing executes yet
var query = numbers
    .Where(n => { Console.WriteLine($"Filtering {n}"); return n > 5; })
    .Select(n => { Console.WriteLine($"Mapping {n}"); return n * 2; });

// Only executes when data is needed
Console.WriteLine("About to execute query");
foreach (var item in query) // Execution happens here
{
    Console.WriteLine($"Result: {item}");
}
```

* LINQ uses [deferred execution](https://learn.microsoft.com/en-us/dotnet/standard/linq/deferred-execution-example)
* Operations chain like a [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming))
* Query builds an expression pipeline
* Execution only happens when enumerated
* Allows efficient processing of large datasets

---

### Pitfalls

* **Single-use enumerators**: Some [IEnumerable sources](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.range) can only be enumerated once
* **Deferred execution**: Changes to source data [affect results](https://learn.microsoft.com/en-us/dotnet/standard/linq/deferred-execution-example)
* **Resource leaks**: Unclosed [database connections](https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/managing-connections) or [file streams](https://learn.microsoft.com/en-us/dotnet/api/system.io.file.openread)
* **Hidden costs**: Some operations force [multiple passes](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution) over data
* **Memory pressure**: Large sequences can cause [performance issues](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/performance-tips)
* **Thread safety**: Most implementations are [not thread-safe](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)

---

### Problematic Connection Management

```csharp title="ConnectionLeakExample.cs"
public static IEnumerable<Person> GetAll() {
    using var connection = new SqlConnection("connection_string");
    connection.Open();
    
    var command = new SqlCommand("SELECT * FROM Person", connection);
    var reader = command.ExecuteReader();
    
    while (reader.Read()) {
        yield return new Person {
            Id = reader.GetInt32(0),
            Name = reader.GetString(1),
            Age = reader.GetInt32(2)
        };
    }
    // Connection remains open until enumeration completes
}
```

---



## Keyword: `yield`

---

### Overview

* Creates [iterator methods](https://learn.microsoft.com/en-us/dotnet/csharp/iterators) without explicit state management
* Produces values on-demand with [deferred execution](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution)
* Compiler generates [state machine](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield) under the hood
* Maintains method state between iterations
* Enables [lazy evaluation](https://learn.microsoft.com/en-us/dotnet/standard/linq/deferred-execution-example) for efficient processing
* Powers many LINQ extension methods
* Can cause resource leaks when [improperly used](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/disposable-resource-usage)

---

### Example (Dumb)

```csharp
public static IEnumerable<string> GetWords() {
    yield return "Hello";
    yield return "World";
}

// Usage
foreach (var word in GetWords()) {
    Console.WriteLine(word);
}
```

---

### Example (Less Dumb)

```csharp
public static IEnumerable<TResult> Map<TSource, TResult>(
    this IEnumerable<TSource> source,
    Func<TSource, TResult> map
) {
    foreach (var item in source) {
        yield return map(item);
    }
}
```

---

### Example: Fibonacci Sequence

```csharp
public static IEnumerable<int> Fibonacci() {
    int previous = 0, current = 1;
    while(true) {
        yield return previous;
        int temp = previous + current;
        previous = current;
        current = temp;
    }
}

```

---




## Common Collections

---

### Overview
* **Workhorses**
  - **[Array](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/)**: Fixed-size contiguous memory block, fastest random access
  - **[List](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)**: Resizable array, best general-purpose collection
  - **[Dictionary](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2)**: Key-value pairs with O(1) lookups
* **Occasionally useful**
  - **[ArrayList](https://learn.microsoft.com/en-us/dotnet/api/system.collections.arraylist)**: Legacy non-generic list, avoid in new code
  - **[HashSet](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1)**: Unique elements, efficient membership testing
  - **[Queue](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1)**: FIFO collection for ordered processing
  - **[Stack](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1)**: LIFO collection for reverse-order processing

---

### Initialization

```csharp
var xs = new List<string>();
xs.Add("a");
xs.Add("b");
xs.Add("c");

var ys = new List<int> { 1, 2, 3 };

List<int> zs = [1, 2, 3];

var bs = [1, 2, 3];

var cats = new List<Cat> {
    new Cat("Whiskers"),
    new Cat("Mittens")
};
```

---

### Range Operator

* Introduced in [C# 12/.NET 8](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12) (November 2023)
* Creates [collection expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions) with simplified syntax
* Solves verbose collection initialization problem
* Enables [spread elements](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions) with `..` syntax
* Works with arrays, lists, and other collection types
* Improves readability by reducing boilerplate code
* Supports inference of most appropriate collection type

---

### Examples
```csharp title="Collection Expressions"
int[] firstList = [1, 2, 3];
List<int> secondList = [1, 2, 3];


// Combining collections with spread operator
int[] combined = [.. firstList, .. secondList];

// Cloning a list
List<int> clone = [.. combined];

// Adding elements
List<int> withMore = [.. combined, 4, 5, 6];

// Mixed operations
List<int> result = [9, .. withMore, 22];
```

---

### On Interfaces

* Interfaces define [contracts](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/) for collections
* Enable [polymorphism](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/polymorphism) and looser coupling
* Allow generic algorithms that work on multiple collection types
* **Why Read-Only Interfaces?**
  - IEnumerable only provides iteration, no direct access
  - [IReadOnlyList](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlylist-1) adds indexing and Count
  - Clearer intent than IEnumerable or casting to concrete types
  - Performance: direct access without LINQ overhead
* Good for [API design](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/guidelines-for-collections) and defensive programming

---

### Interfaces

* **[IEnumerable](https://learn.microsoft.com/en-us/dotnet/api/system.collections.ienumerable)**: Base interface for all collections, enables foreach
* **[ICollection](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.icollection-1)**: Adds size and modification capabilities
* **[IList](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ilist-1)**: Provides indexed access and list manipulation
* **[IDictionary](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.idictionary-2)**: Provides key/value pair access
* Read only
  - **[IReadOnlyCollection](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlycollection-1)**: Read-only view of a collection
  - **[IReadOnlyList](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlylist-1)**: Read-only view with indexed access
  - **[IReadOnlyDictionary](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2)**: Read-only view of key/value pairs

---

### Creating `IReadOnlyCollection<T>`

```csharp
public class Person {
    private readonly List<DateOnly> availableDates;
    public IReadOnlyCollection<DateOnly> AvailableDates => availableDates.AsReadOnly();
}
```

---

### From the End

* **Index from end operator** (`^`) introduced in [C# 8.0](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8)
* Provides [cleaner syntax](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#index-from-end-operator-) for accessing elements from collection end
* Replaces verbose expressions like `array[array.Length - 1]`
* Works with [arrays, spans, and strings](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/ranges)
* Pairs with [range operator](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#range-operator-) for slicing collections
* Strongly typed with [System.Index](https://learn.microsoft.com/en-us/dotnet/api/system.index) struct
* Improves code readability for collections with unknown length

---

### From the End Examples

```csharp title="Index From End Examples"
// Last element
var lastItem = array[^1];  // Same as array[array.Length - 1]

// Third from end
var thirdFromEnd = list[^3];  // Same as list[list.Count - 3]

// Ranges with from-end operator
var lastThreeItems = array[^3..];  // Last three elements

// Slicing with both ends
var middleItems = array[2..^2];  // All but first two and last two

// Works with strings too
var extension = filename[^4..];  // Last four characters
```

