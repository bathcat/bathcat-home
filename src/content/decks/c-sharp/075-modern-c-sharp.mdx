---
title: "Modern C Sharp"
description: "Potpourri of new(ish) C# features. Not all of which will change your life."
status: 'Draft'
flavor: 'Deck'
---
# Modern C#

---

### Goals

1. Lorem
2. Ipsum
3. Sic

---

## Expresion Bodies

---

### Overview
* Terse implemention allows using expression bodies instead of traditional code blocks
* Introduced with C# 6, enhanced by C# 7
* Used for:
  - Method
  - Property
  - Constructor, Finalizer
  - Indexer

---

### Motivating Example 

```csharp
class User{
  string FullName {
    get{
      return $"{this.surname}, {this.givenName}";
    }
  }

  override ToString(){
    return $"[{this.FullName}];
  }
}

```

---

### Terse

```csharp
class User{
  string FullName 
    => $"{this.surname}, {this.givenName}";

  override ToString() 
    =>  $"[{this.FullName}];
}
```

---




## Fancy `using`

---


### Overview
* Old-school C# requires you to import _all_ namespaces with the `using` keyword
* Contemporary developers have options:
  - [Global](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/globalusingdirective) introduced by C# 6
  - [Implicit](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives) introduced by C# 10
* **Advantages**: Less boilerplate, friendlier to newbies
* **Complaints**: Not as explicit, minimal time savings

---




## Top-level Statements

---

### Overview
* [Introduced in C# 9](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements)

> Top-level statements enable you to avoid the extra ceremony
> required by placing your program's entrypoint in a static method in a class.

#### Old and busted **App.cs**

```csharp
using System;
namespace Acme{
  public static void App{
    public static void Main(){
      Console.Writeline("Hello world!);
    }
  }
}


```

---

### New Hotness
* Restrictions:
  - One top-level file per project
  - Live in the global namespace
  - Compiled into a `Main` method by the C# Compiler

```csharp
      Console.Log("Hello world!);
```

---

### Pros and Cons
* **Advantages**
  - Less boilerplate
  - Friendler to newbies
* **Disadvantages**
  - Looks weird to old people
  - Reduced uniformity


---




## Records

---

### Overview
* Introduced by C# 9, refined by C# 10
* Terse syntax for encapsulating data
* Usually [immutable](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#immutability)
* Freebies
  - Value equality
  - `GetHashCode`
  - Sensible default for `ToString`

---

### Motivating Example

```csharp

public class DayOfYear{
  public int Month {get;set;} = 1;
  public int Day {get;set;} = 1;

  public bool Equals(object o){
    o is DayOfYear other && other.Month = this.Month && other.Day==this.Day;
  }
  //TODO: Implement GetHashCode too
}

```
---

### Keyword `record` to the Rescue!

```csharp
public record DayOfYear{
  public required int Month {get;init;};
  public required int Day {get;init;};
}

```

---

### Even Terser Syntax
* Known as a 'primary constructor'
* Creates read-only properties for each argument
```csharp
public record DayOfYear(int Month, int Day);
```

---

### On Immutability
* Advantages: 
  - Easier to reason about
  - Harder to screw up-- especially when sharing state
* Disadvantages:
  - No built-in constructs (in the old days, at least)
  - Replacing mutation with copying adds memory churn

---

### Keyword: `with`
* Enables ['nondestructive mutation'](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#nondestructive-mutation)
* In reality, a fancy way to copy Records

```csharp
public record Login(string ID, string Name, bool isActive, DateTime? DisabledOn);

public static LoginManager{
  public static Login Disable(Login login)
    => login with{
        IsActive = false,
        DisabledOn = DateTime.UtcNow
      };
}

```

---

### Keyword: [`required`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required)

> The required modifier indicates that the field or property it's applied to must be initialized by an object 
> initializer. Any expression that initializes a new instance of the type must initialize all required members. 
> The required modifier is available beginning with C# 11. The required modifier enables developers to create
> types where properties or fields must be properly initialized, yet still allow initialization using object 
> initializers. 


---




## Pattern Matching

---



### Overview

* Introduced in C# 7.0, inspired by functional languages like F# and Haskell
* Solves complex type checking and property matching in a declarative way
* Reduces boilerplate code for type testing and property extraction
* Enables more expressive and readable conditional logic
* Key features:
  - [Type patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#type-patterns) for safe type testing
  - [Property patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#property-pattern) for object property matching
  - [Positional patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#positional-pattern) for deconstructing objects
  - [List patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#list-patterns) for array/list matching (C# 11)

---

### Type Pattern Matching

* Tests and extracts values based on type using `is` operator
* Eliminates need for explicit type casting and null checks
* Introduced in C# 7.0 with [basic type patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#type-patterns)
* Enhanced in C# 9.0 with [relational patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#relational-patterns)
* Common use cases:
  - Safe type testing without exceptions
  - Extracting values from polymorphic objects
  - Combining type checks with property access

---

### Motivating Example

```csharp
public string ProcessShape(Shape shape){
    if (shape is Circle){
        var circle = (Circle)shape;
        return $"Circle with radius {circle.Radius}";
    }
    if (shape is Rectangle){
        var rect = (Rectangle)shape;
        return $"Rectangle {rect.Width}x{rect.Height}";
    }
    return "Unknown shape type";
}
```

---



### Type Pattern Example

```csharp
public string ProcessShape(Shape shape)
{
    if (shape is Circle circle)
        return $"Circle with radius {circle.Radius}";
        
    if (shape is Rectangle rect)
        return $"Rectangle {rect.Width}x{rect.Height}";
        
    if (shape is null)
        return "No shape provided";
        
    return "Unknown shape type";
}
```

---

### Property Pattern Matching

* Tests object properties directly in pattern matching expressions
* Introduced in C# 8.0 with [property patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#property-pattern)
* Enhanced in C# 10.0 with [extended property patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#extended-property-patterns)
* Common use cases:
  - Matching on object state without type checking
  - Combining multiple property conditions
  - Nested property access in patterns

---

### Property Pattern Example

```csharp title='OrderProcessor.cs'
public string GetOrderStatus(Order order)
{
    if (order is { Status: OrderStatus.Pending, Amount: > 1000 })
        return "High value pending order";
        
    if (order is { Customer: { IsVIP: true }, Status: OrderStatus.Processing })
        return "VIP order in processing";
        
    if (order is { Status: OrderStatus.Cancelled, CancellationReason: not null })
        return $"Order cancelled: {order.CancellationReason}";
        
    return "Standard order";
}
```

---

### Positional Pattern Matching

* Matches on object deconstruction using [positional patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#positional-pattern)
* Works with types that implement [Deconstruct](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct)
* Common use cases:
  - Matching on record types
  - Working with tuple-like structures
  - Extracting multiple values in one pattern

---

### Positional Pattern Example

```csharp title='PointProcessor.cs'
public string GetQuadrant(Point point) {
    return point switch {
        (0, 0) => "Origin",
        (var x, var y) when x > 0 && y > 0 => "Quadrant 1",
        (var x, var y) when x < 0 && y > 0 => "Quadrant 2",
        (var x, var y) when x < 0 && y < 0 => "Quadrant 3",
        (var x, var y) when x > 0 && y < 0 => "Quadrant 4",
        _ => "Invalid point"
    };
}
```

---

### List Pattern Matching

* Introduced in C# 11 with [list patterns](https://learn.microsoft.com/en-us/dotnet/csharp/pattern-matching#list-patterns)
* Matches on array or list elements using slice patterns
* Common use cases:
  - Matching sequence prefixes
  - Extracting head and tail elements
  - Validating list structure
* Supports `..` for slice patterns and `_` for discards

---

### List Pattern Example

```csharp title='CommandParser.cs'
public string ParseCommand(string[] args) 
    => args switch {
        ["run", "test", ..] => "Running tests",
        ["build", "release", var target] => $"Building release for {target}",
        ["help", var command] => $"Showing help for {command}",
        ["version"] => "v1.0.0",
        [] => "No command provided",
        _ => "Unknown command"
    };

```

