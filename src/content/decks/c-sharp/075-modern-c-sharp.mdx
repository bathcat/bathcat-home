---
title: "Modern C Sharp"
description: "Potpourri of new(ish) C# features. Not all of which will change your life."
status: 'Live'
flavor: 'Deck'
---
# Modern C#

---

### Goals

1. Lorem
2. Ipsum
3. Sic

---

## Expresion Bodies

---

### Overview
* Terse implemention allows using expression bodies instead of traditional code blocks
* Introduced with C# 6, enhanced by C# 7
* Used for:
  - Method
  - Property
  - Constructor, Finalizer
  - Indexer

---

### Motivating Example 

```csharp
class User{
  string FullName {
    get{
      return $"{this.surname}, {this.givenName}";
    }
  }

  override ToString(){
    return $"[{this.FullName}];
  }
}

```

---

### Terse

```csharp
class User{
  string FullName 
    => $"{this.surname}, {this.givenName}";

  override ToString() 
    =>  $"[{this.FullName}];
}
```

---

## Fancy `using`

---


### Overview
* Old-school C# requires you to import _all_ namespaces with the `using` keyword
* Contemporary developers have options:
  - [Global](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/globalusingdirective) introduced by C# 6
  - [Implicit](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives) introduced by C# 10
* **Advantages**: Less boilerplate, friendlier to newbies
* **Complaints**: Not as explicit, minimal time savings

---

## Top-level Statements

---

### Overview
* [Introduced in C# 9](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements)

> Top-level statements enable you to avoid the extra ceremony
> required by placing your program's entrypoint in a static method in a class.

#### Old and busted **App.cs**

```csharp
using System;
namespace Acme{
  public static void App{
    public static void Main(){
      Console.Writeline("Hello world!);
    }
  }
}


```

---

### New Hotness
* Restrictions:
  - One top-level file per project
  - Live in the global namespace
  - Compiled into a `Main` method by the C# Compiler

```csharp
      Console.Log("Hello world!);
```

---

### Pros and Cons
* **Advantages**
  - Less boilerplate
  - Friendler to newbies
* **Disadvantages**
  - Looks weird to old people
  - Reduced uniformity


--- 

## Records

---

### Overview
* Introduced by C# 9, refined by C# 10
* Terse syntax for encapsulating data
* Usually [immutable](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#immutability)
* Freebies
  - Value equality
  - `GetHashCode`
  - Sensible default for `ToString`

---

### Motivating Example

```csharp

public class DayOfYear{
  public int Month {get;set;} = 1;
  public int Day {get;set;} = 1;

  public bool Equals(object o){
    o is DayOfYear other && other.Month = this.Month && other.Day==this.Day;
  }
  //TODO: Implement GetHashCode too
}

```
---

### Keyword `record` to the Rescue!

```csharp
public record DayOfYear{
  public required int Month {get;init;};
  public required int Day {get;init;};
}

```

---

### Even Terser Syntax
* Known as a 'primary constructor'
* Creates read-only properties for each argument
```csharp
public record DayOfYear(int Month, int Day);
```

---

### On Immutability
* Advantages: 
  - Easier to reason about
  - Harder to screw up-- especially when sharing state
* Disadvantages:
  - No built-in constructs (in the old days, at least)
  - Replacing mutation with copying adds memory churn

---

### Keyword: `with`
* Enables ['nondestructive mutation'](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#nondestructive-mutation)
* In reality, a fancy way to copy Records

```csharp
public record Login(string ID, string Name, bool isActive, DateTime? DisabledOn);

public static LoginManager{
  public static Login Disable(Login login)
    => login with{
        IsActive = false,
        DisabledOn = DateTime.UtcNow
      };
}

```

---

### Keyword: [`required`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required)

> The required modifier indicates that the field or property it's applied to must be initialized by an object 
> initializer. Any expression that initializes a new instance of the type must initialize all required members. 
> The required modifier is available beginning with C# 11. The required modifier enables developers to create
> types where properties or fields must be properly initialized, yet still allow initialization using object 
> initializers. 


---

## Pattern Matching

---

### Overview
* 