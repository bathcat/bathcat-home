---
title: "Unmanaged Resources"
description: "Dealing non-managed resources, like file handles, network and database connections means understanding and implementing IDisposable."
status: 'Live'
flavor: 'Deck'
---



# Unmanaged Resources

---

### Goals

1. Explain the difference between managed and unmanaged resources in .NET.
2. Describe why unmanaged resources require explicit cleanup using `IDisposable`.
3. Explain the `using` statement and when to use it.

---



## Managed Resources

---

### What's a 'Managed Resource'?
* Managed code means [garbage collection](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)
* Lifetime managed by the .NET runtime
* Automatically allocated and reclaimed
* Examples: Most standard C# objects (strings, lists, custom classes)
* Developers generally don't need to manually release memory for these

---

### [Garbage Collection Basics](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)
* Automatic memory management in .NET framework
* **Non-deterministic** - you cannot predict exactly when collection occurs
* Frees developers from manual memory management
* Prevents common memory issues like leaks and dangling pointers
* Provides [`GC` class](https://learn.microsoft.com/en-us/dotnet/api/system.gc?view=net-8.0) for interaction (e.g., `GC.Collect()`) but **explicit calls are rarely needed**

---

### [What's _Not_ GCed](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals#workstation-and-server-garbage-collection)
*   **Value types** (structs, primitives) often live on the **stack**.
    *   Stack memory is cleaned automatically when a method exits (stack unwinds) - **this is _not_ GC**.
*   **Neither GC nor stack cleanup** handle **unmanaged resources** like:
    *   File Handles (e.g., `FileStream`)
    *   Database Connections (e.g., `SqlConnection`)
    *   Network Sockets (e.g., `Socket`, `NetworkStream`)
    *   Window Handles, COM Objects, raw memory pointers (interop)
*   These unmanaged resources require **explicit cleanup** (usually via `IDisposable` and `using`).

---




## Unmanaged Resources

---

### What Are Unmanaged Resources?
* Resources not managed by the .NET runtime
* Require **explicit release** as they consume system resources
* Non-deterministic GC is **insufficient** for these resources
  - Critical resources might remain open too long
  - Can lead to resource exhaustion (file handle limits, connection pools)

---

### Partial Leaks
* Some built-in types (like `SqlConnection`, `FileStream`) wrap unmanaged resources.
  - **Usually have finalizers** as a safety net.
  - If you forget `Dispose()`, the finalizer **might eventually** run during GC and release the resource
* **Problem:** This is **non-deterministic**! Scarce resources stay open!

---

### Total Leaks
* **If**
  - *Your* class directly holds a raw handle (e.g., from P/Invoke, COM interop) 
  - **And** you forget `Dispose()`
* ***It will _leak_*** unless you also implement a finalizer (which is complex and rare).
* The Garbage Collector **doesn't see** these non-.NET resources.
  - The resource is **never released** (a "total" leak).
  - Unlike built-in types, there's often no finalizer safety net here.

---

### Pattern [IDisposable](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose)
* Interface for **explicit resource cleanup**
* Provides deterministic release of unmanaged resources
* Implemented by types holding scarce or expensive resources
* Call `Dispose()` method when done with the resource
* Enables the ["using" statement](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/using) for automatic cleanup

---

### Common Examples
#### Lots of library/framework types implement `IDisposable`
* [DbContext](https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext) - Entity Framework database contexts
* [HttpClient](https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient) - HTTP communication
* [FileStream](https://learn.microsoft.com/en-us/dotnet/api/system.io.filestream) - File handles and operations
* [SqlConnection](https://learn.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection) - SQL Server database connections
* [Socket](https://learn.microsoft.com/en-us/dotnet/api/system.net.sockets.socket) - Network communication endpoints

---

### Explicit Disposal Example

```csharp title='ExplicitDisposal.cs'
// Note to self: Don't do this!
byte[] GetFirstTenBytes(string file){
  FileStream fs = new FileStream(file, FileMode.Open);
    
  byte[] data = new byte[10];
  fs.Read(data, 0, data.Length);    
  fs.Dispose(); // Make sure to clean up!

  return data;
}
```

---

### Remember Exceptions
* When an exception is thrown, execution stops
* So the rest of the function doesn't run
* Does the stream _ever_ get closed?


---

### Improved ExplicitDisposal (I)

```csharp title='ExplicitDisposal.cs'
byte[] GetFirstTenBytes(string file){
  byte[] data = new byte[10];
  FileStream? fs = null;
  try{
    fs = new FileStream(file, FileMode.Open);
    fs.Read(data, 0, data.Length);
  }
  finally{
    if(fs != null)
      fs.Dispose();
  }
  return data;
}
```

---

### The `using` Statement
* Keyword: [`using`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/using)
* Automatically disposes `IDisposable` objects even if exceptions occur
* Shorter, cleaner syntax than `try`/`finally` blocks
* Creates a limited scope for the resource (optionally)

---

### Improved ExplicitDisposal (II)

```csharp title='UsingExample.cs'
byte[] GetFirstTenBytes(string file){
  byte[] data = new byte[10];
  
  using (FileStream fs = new FileStream(file, FileMode.Open))
  {
    fs.Read(data, 0, data.Length);
  } // fs.Dispose() automatically called here
  
  return data;
}

```

---

### Improved ExplicitDisposal (III)

```csharp
// C# 8.0+ simplified syntax
byte[] GetFirstTenBytesModern(string file){
  byte[] data = new byte[10];
  
  using var fs = new FileStream(file, FileMode.Open);
  fs.Read(data, 0, data.Length);
  // fs.Dispose() called at end of method
  
  return data;
}
```

---

### Rules
* If ___you___ instantiate an `IDisposable` ___you___ need to dispose of it
* Most C#/.NET performance issues come from not calling dispose
* The `using` keyword is the best bet

---




## Custom IDisposable

---

### Overview
* [Implement `IDisposable` when your class:](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose)
  - Owns unmanaged resources (COM objects, file handles, etc.)
  - Contains fields that are `IDisposable`
* Examples:
  - Custom database wrapper: `MyDbWrapper : IDisposable`
  - Custom stream implementation: `EncryptedFileStream : Stream, IDisposable`
* Provides deterministic cleanup for your users
* Required for classes that can be used with `using` statements

---

### Dispose Recipe (Simple Case)
*   Add a `private bool _disposed` flag
*   Implement the public `Dispose()` method:
    * Ensure no double disposal
    * Call `Dispose()` on any owned `IDisposable` fields (e.g., streams, connections).
*   **No finalizer** (`~ClassName`) needed if you *only* hold managed `IDisposable` objects.

---

### Simple Example: FileLogger

```csharp title="FileLogger.cs"
public class FileLogger : IDisposable{
    private readonly StreamWriter _writer;
    private bool _disposed = false;

    public FileLogger(string logFilePath)
      =>  _writer = new StreamWriter(logFilePath, append: true);
    
    public void Dispose(){
        if (_disposed) 
          return;
        _writer?.Dispose();
        _disposed = true;
    }
    // Assume WriteLog(string message) exists...
}
```

---

### Goofy Pattern: Guard Clause
* [`IDisposable`](https://learn.microsoft.com/en-us/dotnet/api/system.idisposable) isn't just for files/connections; it can guard **application state**.
* Recipe: 
  - Constructor *changes* some global setting (e.g., logging level).
  - `Dispose` *restores* the original setting.
* [`using` statement](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/using) guarantees the state is reset, even if errors occur.
* Robust way to temporarily alter and reliably restore shared state

---

### Motivation

```csharp title="Sloppy.cs"

public static void DoStuffWithoutLogging(){
    Logger.Instance.Level = LogLevel.None;
    // Do stuff. It won't be logged. 
    Logger.Instance.Level = LogLevel.Normal;
}

```

```csharp title="LessSloppy.cs"

public static void DoStuffWithoutLogging(){
    Logger.Instance.Level = LogLevel.None;
    try{
        // Do stuff. It won't be logged. 
    }
    finally{
        Logger.Instance.Level = LogLevel.Normal;
    }
}

```

---

### Guard Clause Example

```csharp title="GuardClauseExample.cs"
public class NoLogGuard : IDisposable{
    private readonly LogLevel originalLevel;

    public NoLogGuard(){
        // Logger.Instance is the singleton accessor

        // Save the original log level
        originalLevel = Logger.Instance.Level;

        // Set the log level to 0 (no logging)
        Logger.Instance.Level = LogLevel.None;
    }

    public void Dispose()
        => Logger.Instance.Level = originalLevel;
}
```

---

### Guard Clause Example

```csharp title="GuardClauseExample.cs"

public static void DoStuffWithoutLogging(){
    var guard = new NoLogGuard();
    // Do stuff. It won't be logged. 
    // BUT the log level gets set back to normal on dispose!
}

```





---



## Finalizers

---


### Finalize
* Last-resort cleanup is the [finalizer](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers)
* Syntax: `~ClassName() { /* cleanup code */ }`
* **Non-deterministic** 
  - Called by GC before object reclamation
* **Rarely needed!** Only for class members that are not `IDisposable`

---

### Dispose ain't Finalize
* [`Dispose()`](https://learn.microsoft.com/en-us/dotnet/api/system.idisposable.dispose): 
  - **You** call it 
  - Explicitly or `using`
  - Deterministic cleanup
* [`~ClassName()`](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers): 
  - **GC** calls it
  - Non-deterministic safety net
* **Theme:** Resource cleanup. Different triggers, different guarantees.


---


### Partial Leak Explained
* Most .NET classes that implement `IDisposable` also have a finalizer
  - e.g. `Stream`, `SqlConnection`, `HttpClient`
* So even if you forget to dispose, the finalizer will eventually run
* This is why it's called a "partial leak"

---

### Implement a Finalizer When...

* **Rarely needed!** You usually don't need to write a [finalizer (`~ClassName`)](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers).
* **Only** if your class *directly* holds **unmanaged resources** (raw handles, native memory, COM objects).
* This typically happens with [Platform Invoke (P/Invoke)](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke) or [COM Interop](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/com-interoperability).
* **NOT** when your class only holds *managed* `IDisposable` objects (like `FileStream`, `SqlConnection`).
* These base classes often have their *own* finalizers as a safety net.

---


### Syntax Example

```csharp title="ComAdapter.cs"
public class Enfarculator {

  // Finalizer:Called by GC before object reclamation
  // NOTE:
  //   - No access modifier
  //   - No parameters
  //   - No calling convention
  ~Enfarculator() {
    // Cleanup code
  }
}

```




---

### Dispose Pattern Recipe (Full)
* Implement both `Dispose()` and `Dispose(bool)` methods
* Use `protected virtual` for `Dispose(bool)` to allow inheritance
* Call `Dispose(true)` from `Dispose()` and finalizer
* Set fields to `null` after cleanup
* Set `disposed` flag to prevent multiple disposals
* [Implementing the Dispose Pattern](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose#implement-the-dispose-pattern)
* [Best Practices for Dispose](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose#implement-the-dispose-pattern-for-a-derived-class)

---

### Example (Part 1): Creation

```csharp title='ComAdapter.cs'
public class ComAdapter : IDisposable {
    private IntPtr _comHandle;
    private bool _disposed;
    private readonly object _lock = new object();

    public ComAdapter() {
        // Simulate COM object creation
        _comHandle = Marshal.AllocHGlobal(1024);
    }
}
```

---

### Example (Part 2): Dispose()

```csharp title='ComAdapter.cs'
    /// <remarks>
    /// Called by the user explicitly-- or with a `using` block
    /// </remarks>
    public void Dispose() {
        // Delegate to Dispose(bool)
        Dispose(true);

        // Avoid running this twice
        GC.SuppressFinalize(this);
    }
```

---

### Example (Part 3) Dispose(bool)

```csharp title='ComAdapter.cs'
    protected virtual void Dispose(bool disposing) {
        if (_disposed) return;
        lock (_lock) {
            if (_disposed) return;
            if (_comHandle != IntPtr.Zero) {
                Marshal.FreeHGlobal(_comHandle);
                _comHandle = IntPtr.Zero;                
            }
            if (disposing) {
                // Add managed resource cleanup here
            }
            _disposed = true;
        }
    }


}
```

---

### Example (Part 4) Finalize(bool)
```csharp
/// <summary>
/// Finalizer - Last backstop in case Dispose didn't get called
/// </summary>
~ComAdapter() {
    // Safe to call from finalizer - uses native Windows API
    Debug.WriteLine("WARNING: ComAdapter finalizer called."+
      " Resource hasn't been properly disposed."
    );
    
    Dispose(false);
}
```

---

### Takeaways

*   You will ***use*** `IDisposable` far more often than you will *implement* it.
*   If you *do* implement `IDisposable`, you often **don't need a finalizer**.
    *   Finalizers are *only* for classes directly holding unmanaged handles.
*   Don't memorize the full Dispose Pattern Recipe; look it up when needed.
*   **ALWAYS** ensure `IDisposable` objects you create/own are disposed

---


## Fin

---

### Review

1. Explain the difference between managed and unmanaged resources in .NET.
2. Describe why unmanaged resources require explicit cleanup using `IDisposable`.
3. Explain the `using` statement and when to use it.
