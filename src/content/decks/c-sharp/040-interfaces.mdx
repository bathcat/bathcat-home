---
title: "Interfaces"
description: "Limitations of classical OO, motivations for interfaces, and how to use them."
status: 'Live'
flavor: 'Deck'
---


# Interfaces

---

### Goals

1. Explain the difference between interfaces and classes
2. List 3 benefits of using interfaces
3. Describe the trade-offs of default interface implementations

---

### Roadmap

1. Basics
2. Real Life Example
3. Default Implementations
4. Explicit Implementations
5. Patterns


---



## Basics

---

### Problems with classical OO
* [**Tight coupling**](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#dependency-inversion) between implementations makes code hard to change
  - Slogan: 'new is glue'
* [**Inheritance hierarchies**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance) 
  - Can add artificial complexity
  - Are difficult to reason about
* **Multiple inheritance**
  - Is not supported in C#
  - Is kind of bogus anyway
* **Shared mutable state** makes reasoning about [concurrency difficult](https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism)

---


### Problems with Pure Functions
* Object-oriented programming is supposed to overcome the problems of pure functions
* But pure functions are still useful
  - Reason about
  - Test
  - Maintain
* Limitations are about
  - State
  - Side effects
  - Grouping - i.e. a capability requires a group of related functions

---

### Introducing the Interface
* [Interfaces](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface) define contracts without implementation details
* Declared with `interface` keyword
* Can inherit from multiple interfaces
* Classes implement interfaces with `:` notation
* Enables [dependency injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection) and loose coupling
* Supports [default implementations](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods) since C# 8.0
* Great for testability and code maintainability

---

### Example: Throwaway

```csharp
interface IThrowaway{
  void DoSomething();
  string Name { get; }
}
```

#### Things to Notice
* No access modifiers
* No implementation

---

### Implementing the Interface

```csharp title="ConsoleThrowaway.cs"
class ConsoleThrowaway : IThrowaway{  
  public void DoSomething() => Console.WriteLine("Doing something");
  public string Name => "Throwaway";
}
```

```csharp title="FileThrowaway.cs"
class FileThrowaway : IThrowaway{
  public void DoSomething() => File.WriteAllText("throwaway.txt", "Doing something");
  public string Name => "Throwaway";
}
```

---

### Consuming the Interface

```csharp
void Consume(IThrowaway throwaway){
  throwaway.DoSomething();
  Console.WriteLine(throwaway.Name);
}
```

#### Things to Notice
* `Consume` doesn't care about the implementation
* `Consume` can be tested with different implementations
* `Consume` is loosely coupled

---

### Takeaways
* An interface represents:
  - A **contract** enforced by the compiler
  - A **capability** that can be used interchangeably
  - A **group of related functions**

---




## Real Life Examples

---

### In .NET
* [IDisposable](https://learn.microsoft.com/en-us/dotnet/api/system.idisposable) - Provides deterministic resource cleanup
* [IComparable](https://learn.microsoft.com/en-us/dotnet/api/system.icomparable) - Defines sorting order for objects
* [IEnumerable](https://learn.microsoft.com/en-us/dotnet/api/system.collections.ienumerable) - Enables iteration with foreach
* [ILogger](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger) - Core logging abstraction
* [IEquatable](https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1) - Defines value equality

---

### Example #2: Enfarculator
```csharp title="Enfarculator.cs"
class Enfarculator{
  private readonly ILogger<Enfarculator>  logger;

  public Enfarculator(ILogger<Enfarculator> logger) 
    => this.logger = logger;

  public void Enfarculate(){
    logger.Log("Commencing enfarculation...");
    // Do actual enfarculation
    logger.Log("Enfarculation complete");
  }
}
```

---

### Enfarculator Factory
* In production code, we'll use a real logger

```csharp
class EnfarculatorFactory{
  public static Enfarculator Create() 
    => new Enfarculator(new EventLogLogger<Enfarculator>());
}
``` 

---

### Enfarculator Unit Tests
* We want to test the `Enfarculator` class
* We want to use a fake logger

```csharp title="NoOpLogger.cs"
class NoOpLogger : ILogger<T>{
  public void Log(string message) {}
}
```

```csharp title="Enfarculator.Tests.cs"
[TestMethod()]
public void Enfarculator__Should_Enfarculate_Properly() {
    var subject = new Enfarculator(
      new NoOpLogger<Enfarculator>()
    );
    
    // Etc....
}
```


---




## Default Implementations

---

### Overview
* [Default implementations](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods) allow **interfaces can now include actual method code**
* **Trade-off**: Pragmatism vs conceptual purity
* [**Use case**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods#motivation)
  - Backwards compatibility
  - [Traits](https://en.wikipedia.org/wiki/Trait_(computer_programming))
* **Criticisms** 
  - Blurs distinction between interfaces and abstract classes
  - Weakens interfaces as pure contracts

---

### Example: Notification Service (Original)

```csharp title="INotificationSender.cs"
public interface INotificationSender{
    void SendNotification(string message);
}
```

```csharp title="EmailNotificationSender.cs"
public class EmailNotificationSender : INotificationSender{
  public void SendNotification(string message) => //Send email
}
```

---

### Example: Add Dry Run (With Priority)

```csharp title="INotificationSender.cs"
public interface INotificationSender{
    void SendNotification(string message);
    void SendNotification(string message, bool dryRun){
      if(!dryRun)
        SendNotification(message);
    }
}
```

```csharp title="SmsNotificationSender.cs"
public class SmsNotificationSender : INotificationSender{
    public void SendNotification(string message) => // Send SMS ; 
    public void SendNotification(string message, bool dryRun){
      if(!dryRun) SendNotification(message);
      else Console.WriteLine($"SMS (dry run): {message}");
    }
}
```

---




## Explicit Implementations

---

### Overview
* [Explicit implementation](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation) uses `InterfaceName.MethodName` syntax
* Motivation:
  - Resolve method name conflicts between multiple interfaces
  - Get more help from the compiler
  - Hide implementation details from normal class usage
* Mechanics:
  - Can only be accessed through interface reference

---

### Example: IGun / ICamera

```csharp title="IGun.cs"
public interface IGun{
  void Shoot();
}
```

```csharp title="ICamera.cs"
public interface ICamera{
  void Shoot();
}
```

---

### Example: Implementing IGun and ICamera

```csharp title="Camera.cs"
public class GunWithCamera : IGun, ICamera{
  void ICamera.Shoot() => Console.WriteLine("Shooting with camera");
  void IGun.Shoot() => Console.WriteLine("Shooting with gun");
}

void Main(){
  var thing = new GunWithCamera();
  thing.Shoot(); // Compile Error

  ((IGun)thing).Shoot(); // OK
  ((ICamera)thing).Shoot(); // OK
}

```

---




## Patterns

---

### Schools of Thought
* **Over-engineers** think:
  - Every class should implement an equivalent interface
  - Every client should use an interface reference
* What's undebatable:
  - **Testing** is easier with interfaces
  - **Code is more flexible** when it's loosely coupled

---

### Example: Program.cs

```csharp {8-15}
public static class ServiceCollectionExtensions{
   public static HostApplicationBuilder AddCliServices(
      this HostApplicationBuilder builder
   ){
      builder.Configuration.AddJsonFile("appsettings.json");
      builder.Services.AddTransient<AppDbContext>();
      
      builder.Services.AddSingleton<IMutableStore<string, Game>, DbGameStore>();
      builder.Services.AddSingleton<IChatCompletionAdapter, DeepSeekAdapter>();
      builder.Services.AddTransient<IConversationStore, DbConversationStore>();
      builder.Services.AddTransient<IStore<string, PlayerInfo>, DbPlayerInfoStore>();
      builder.Services.AddTransient<IStore<string, Player>, DbPlayerStore>();
      builder.Services.AddTransient<IChatCompletionBot, CompletionBot>();
      builder.Services.AddTransient<IGameEvaluator, GameEvaluator>();
      builder.Services.AddTransient<IConversationService, ConversationService>();

      return builder;
   }
}


```





---

### Testing

```csharp
public class SnakesController : Controller
{
    private readonly IRepository<Snake, Guid> repo;
    private readonly ILogger<SnakesController> logger;

    public SnakesController(IRepository<Snake, Guid> repo, ILogger<SnakesController> logger){
        this.repo = repo;
        this.logger = logger;
    }

    public IEnumerable<Snake> Get(){
        // Etc.
    }
}

```

---

### Mocking Interfaces (with Moq)

```csharp
[TestMethod()]
public void Get__Should_Return_Snakes() {
    var mockRepo = new Mock<IRepository<Snake, Guid>>();
    var testSnakes = new List<Snake> { 
        new Snake { Id = Guid.NewGuid(), Name = "Python" },
        new Snake { Id = Guid.NewGuid(), Name = "Cobra" }
    };
    mockRepo.Setup(repo => repo.GetAll()).Returns(testSnakes);    
    var controller = new SnakesController(mockRepo.Object, nullLogger);
    // Act
    var result = controller.Get();
    // Assert
    Assert.AreEqual(2, result.Count());
}
```

---




## Fin

---


### Review

1. Explain the difference between interfaces and classes
2. List 3 benefits of using interfaces
3. Describe the trade-offs of default interface implementations
