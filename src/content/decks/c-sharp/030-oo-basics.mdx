---
title: "Objects: The Basics"
description: "Introducing object-oriented programming in C#: classes, fields, properties, constructors, and methods."
status: 'Live'
flavor: 'Deck'
---



# Objects: The Basics

---

### Goals

1. Explain the purpose of the `class` keyword
2. List 3 access modifiers
3. Explain the keyword `value`
4. Describe reasons to be cautious with keyword `new`

---

### Roadmap

1. OO in C#
2. Fields
3. Properties
4. Constructors
5. Methods
6. Instantiation

---



## OO in C#

---

### OO Defined

* [Object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) combines data and behavior into a single unit called an object
* Objects maintain [state](https://en.wikipedia.org/wiki/State_(computer_science)) (fields) and expose [behavior](https://en.wikipedia.org/wiki/Behavior-driven_development) (methods)
* Facilitates code reuse, modularity, and separation of concerns

---

### Core OO Principles
1. [Encapsulation](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/encapsulation): Hide implementation details, expose controlled interfaces
1. [Inheritance](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/inheritance): Derive new types from existing ones
1. [Polymorphism](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/polymorphism): Objects can take different forms at runtime
1. [Abstraction](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/abstractions): Model complex systems using simplified representations

---

### OO in C#

* Key language constructs:
  - [`class`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class): Defines a reference type that encapsulates data and behavior
  - [`new`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/new-operator): Creates instances of types at runtime
* Strong type system with compile-time checking
* Built-in support for common OO patterns and practices
* [Properties](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties) provide controlled access to object state

---

### Example
```csharp
class Person{
  public string Name { get; set; }
  public int Age { get; set; }
}
Person p = new Person();
p.Name = "John";
p.Age = 30;
```

---

### Words of Caution
* OO was [dominant in the early 2000s](https://en.wikipedia.org/wiki/Object-oriented_programming#History)
* Pure OO systems can become:
  - Brittle through [tight coupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming))
  - Hard to test
  - [Difficult to parallelize](https://www.microsoft.com/en-us/research/publication/objects-have-failed-notes-for-a-debate/) safely
* Modern C# is [multi-paradigm](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/#object-oriented-and-component-oriented)


---




## Fields

---

### Overview

* [Fields](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/fields) are variables declared at the class level
* Also known as 'data members'
* Store the state of an object
* Best practices:
  - Keep fields [`private`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private)
  - Make them [`readonly`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly) when possible
* Common [naming convention](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions): camelCase with optional underscore prefix
---

### Example

```csharp
class Person{
  private int age;
  private string name;
  private string email;
}
```

---

### Access Modifiers

* Control the visibility and accessibility of types and members
* Available modifiers:
  - [`public`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public): Accessible from anywhere
  - [`private`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private): Accessible only within the containing type
  - [`protected`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected): Accessible within the type and derived types
  - [`internal`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal): Accessible within the same assembly
  - [`protected internal`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal): Accessible within the assembly or derived types
  - [`private protected`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected): Accessible within containing type or derived types in same assembly
* [Default accessibility](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers) is `private` for members, `internal` for types


---

### Fatherly Advice
* **Always** `private` for fields
* **Never** accept the default-- i.e. be explicit
* **>95%** of the time use `private` or `public` 

---

### Keyword: `readonly`
* [Readonly](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly) fields are initialized at runtime
* Can be initialized in constructor or with an initializer
* Cannot be changed after initialization
* Not enforced at runtime

---

### Example
* Follows the [explicit dependency principle](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/dependency-injection) 
* If data can't change it can't get borked up

```csharp
class PersonsController{
  private readonly IPersonRepository repository;

  public PersonsController(IPersonRepository repository){
    this.repository = repository;
  }
  // ...
}
```

---

### Keyword: `static`
* [Static](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static) fields are shared across all instances of a class
* Can be initialized with a static constructor
* Can be used to implement [design patterns](https://en.wikipedia.org/wiki/Design_Patterns) like [Singleton](https://en.wikipedia.org/wiki/Singleton_pattern)
* Often a bad idea!

---

### Example: `static` field
* Shared mutable state is a recipe for disaster
```csharp
class Person{
  public static int Count = 0;

  public Person(){
    Count++;
  }
}
```

---

### Keyword: `const`
* [Const](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/const) fields are compile-time constants
* Conceptually similar to `static readonly`
* Must be initialized at declaration with compile-time constant values
* Enforced at runtime via text substitution
* Similar to a macro in C

---

### Example: `const` field

```csharp
class Person{
  public const int MaxAge = 150;
}
```

---









## Properties

---

### Motivating Example (I)

* Classes should protect invariants
* BUT public fields let anyone create invalid state

```csharp title='Person.cs'
class Person{
  public int age;
}
// Elsewhere
var p = new Person();
p.age = -30;
```

---

### Motivating Example (II)

```csharp title="Person.cs"
class Person{
  private int age;
  // Getters and Setters are ok. 
  // But not ergonomic
  public int GetAge() => age;
  
  public void SetAge(int value){
    if(value <= 0 || value > 150){
      throw new ArgumentException("Bogus age");
    }
    this.age = value;
  }
}

// Elsewhere
var p = new Person();
p.SetAge(-30);
```

---

### What's a [Property](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/using-properties)?

> Properties combine aspects of both fields and methods. To the user of an object, a property appears to
> be a field; accessing the property requires the same syntax. To the implementer of a class, a property
> is one or two code blocks, representing a get accessor and/or a set or init accessor.

---

### Example, Old School I

```csharp
class Person{
  private int age;

  public int Age{
    get { return age;}
    set {this.age = value;} //Notice 'value'
  }
}

// Elsewhere
var p = new Person();
p.SetAge(-30); // Still ok!

```


---

### Example, Old School II

```csharp
class Person{
  private int age;

  public int Age{
    get { return age;}
    set {
      if(value <= 0 || value > 150){
        throw new ArgumentException("Bogus age");
      }
      this.age = value;
    }
  }
}

// Elsewhere
var p = new Person();
p.SetAge(-30); // Throws!
````

---

### Example, [Auto-Implemented](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties)

```csharp
class Person{
  public int Age{
    get;
    set;
  }
}

```

---

### [Accessibility](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/restricting-accessor-accessibility)

* Getters and setters don't have to get the same accessibility

```csharp
class Person{
  public int Age{
    get;
    private set;
  }
}

```

---

### Keyword: `init`
* Often paired with `required` keyword
* Enable immutable data classes
* Can only be set on initialization

```csharp
public class Person{
  public required Guid ID{get;init;}
  public required int Age{get;init;}
  public required string GivenName{get;init;}
  public required string Surname{get;init;}  
}

```

---


### Pros and Cons

* **Pros**
  - Allows changes without breaking binary compatibily
  - Easy to consume
* **Cons**
  - Obscures intention
  - Can't be passed as a variable
  - Encourages runtime validation instead of compile time


---




## Constructors

---

### Overview
* [Constructors](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors) are special methods used to initialize objects
* Initialize fields and perform setup tasks
* Can have parameters and optional parameters

---

### Example

```csharp
class Die{
  private int sides;
  private Random random;

  public Die(int sides, Random random){
    this.sides = sides;
    this.random = random;
  }

  public Die(int sides = 6):
    this(sides, new Random())
  {}

  public int Roll() => random.Next(1, sides + 1);
  
}
```

---

### Chaining
* [Constructor chaining](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors#constructor-chaining) allows one constructor to call another
* Use `: this()` to call another constructor in the same class
* Use `: base()` to call a constructor in the base class
* Common pattern for:
  - Providing default values
  - Reducing code duplication
  - Implementing the [DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)
* Best practice: Chain to the most specific constructor

---


### Example: Chaining

```csharp title='Person.cs'
class Person {
    private readonly string name;
    private readonly int age;
    private readonly string email;

    // Most specific constructor
    public Person(string name, int age, string email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    // Chain to most specific, providing default email
    public Person(string name, int age) 
        : this(name, age, $"{name.ToLower()}@example.com") {}

    // Chain to most specific, providing default age and email
    public Person(string name) 
        : this(name, 0) {}
}
```

---




## Methods

---

### Overview
* [Methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods) are functions attached to objects (or types)
* Same access modifiers as fields
* Can have parameters, return values, and optional parameters
* Can be [virtual](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual) or [abstract](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract)
* One-liners can use expression body

---


### Example

```csharp
class Person{
  public string Name { get; set; }
  public int Age { get; set; }

  public void Greet(){
    Console.WriteLine($"Hello, my name is {Name} and I am {Age} years old.");
  }

  public int Add(int a, int b){
    return a + b;
  }
}
```

---

### Expression-bodied Methods
* Shorthand for 1-line methods
* Implicit `return`
* Compiles to the same thing
* Use fat-arrow syntax =>

```csharp
class Person{
  public string Name { get; set; }
  public int Age { get; set; }

  public void Greet()
    => Console.WriteLine($"Hello, my name is {Name} and I am {Age} years old.");
  
  public int Add(int a, int b)
    => a + b;
}
```

---

### About Parameters

* Parameters are [type/name pairs](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods#method-parameters) separated by commas
* [Optional parameters](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments#optional-arguments) have default values: `void Method(int x = 10)`
* Pass-by-reference options ([`ref`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref)/[`out`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out-parameter-modifier)) exist but are rarely needed

---

### Example: Parameters

```csharp
class Person{
  public static void Greet(string name, int age = 0) =>
    Console.WriteLine($"Hello, my name is {name} and I am {age} years old.");
}
```

---

### Calling Methods

* Methods are called using the object/instance name, followed by a dot, method name, and parentheses
* [Named parameters](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments#named-arguments) improve readability: `Method(x: 10, y: 20)`
* Order doesn't matter when using named parameters
* Can mix positional and named parameters (positional must come first)

---

### Example: Calling Methods

```csharp title='MethodCalls.cs'
class Person {
    public void UpdateProfile(string name, int age, string email) {
        // ... implementation
    }
}

var person = new Person();
// Named parameters can be in any order
person.UpdateProfile(age: 30, name: "John", email: "john@example.com");
```

---




## Instantiation

---

### Overview
* [Instantiation](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers) is the process of creating an object from a class
* Using `new` keyword
* Options:
  - [Object initializer](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#object-initializers)
  - Constructor
* Best practice: Use [dependency injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection) instead of direct instantiation

---

### Example I

```csharp
class Person{
  public string Name { get; set; }
  public int Age { get; set; }
}

var p = new Person();
p.Name = "John";
p.Age = 30;
```

---

### Example II

```csharp
class Person{
  public string Name { get; set; }
  public int Age { get; set; }

  public Person(string name, int age){
    Name = name;
    Age = age;
  }
}

var p = new Person("John", 30);
```


---

### Syntax: Object Initializer

* [Object initializer syntax](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#object-initializers) uses curly braces after `new`
* Properties are set using assignment syntax
* Can be used with or without a constructor
* Properties must be [public](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public) and have a setter
* Order of property assignments doesn't matter
* Cannot set readonly fields or properties

---

### Example III

```csharp
class Person{
  public string Name { get; set; }
  public int Age { get; set; }

  public Person(string name, int age){
    Name = name;
    Age = age;
  }
}


var p = new Person{
  Name = "John",
  Age = 30
};
```

---

### "new" is Glue

* Using `new` [couples](https://en.wikipedia.org/wiki/Tight_coupling) your code to specific implementations
* Better approach: [Program to interfaces](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/abstractions-abstract-types-and-interfaces)
* [Dependency Injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection):
  - Makes components more testable and modular
  - Implements the [Explicit Dependency Principle](https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#explicit-dependencies)
* More to come

---

### Glue Antipattern

```csharp
class PersonsController{
  private readonly IPersonRepository repository;

  public PersonsController(){
    this.repository = new DbPersonRepository();
  }
  // ...
}
```

---

### Keyword: `this`
* [`this`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this) refers to current object instance
* Required to resolve name conflicts (e.g., parameter vs field)
* Optional for accessing members
* Style choice in most cases
* Used in extension methods and indexers

---

### Example: `this`

```csharp
public class Person{
  private string name;
  private int age;

  public Person(string name, int age){
    this.name = name;
    this.age = age;
  }
}

```

---




## Enumerations

---

### [Overview](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum)

* [Enumeration type](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum) maps labels to integral values
* Provides type safety over magic numbers/strings
* Can be [signed or unsigned](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum#enumeration-types-as-bit-flags)
* Supports [bit flags](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum#enumeration-types-as-bit-flags) with `[Flags]` attribute
* Values can be [explicitly specified](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum#enumeration-types-as-bit-flags)
* Best practice: Use for fixed sets of related values

---

### Motivating Example #1
* Booleans aren't extensible

```csharp {3}
public class Login{
    string username = "";
    bool isActive = false; // TODO: Support Paused / Suspended
}
```

---

### Motivating Example #2

* Magic constants are easy to forget, easy to mess up
```csharp {3}
public class Login{
    string username = "";
    int statusCode = 22; //What's this?
}
```


---

### Example

```csharp {8}
enum Status{
  Active,
  Paused,
  Suspended
}
public class Login{
    string username = "";
    Status MyStatus = Status.Active;
}
````

---

### Example 2: Colors

```csharp title='ColorWavelengths.cs'
enum ColorWavelength {
    Red = 700,
    Orange = 600,
    Yellow = 580,
    Green = 550,
    Blue = 470,
    Violet = 400
}

public string GetColorInfo(ColorWavelength color) =>
    $"{color} light has a wavelength of {(int)color}nm";

```

---



## Fin

---


### Review

1. Explain the purpose of the `class` keyword
2. List 3 access modifiers
3. Explain the keyword `value`
4. Describe reasons to be cautious with keyword `new`