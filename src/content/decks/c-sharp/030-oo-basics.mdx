---
title: "Objects: The Basics"
description: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla dapibus consectetur nisl, non ultrices metus pulvinar ut. Nullam hendrerit, magna et congue ullamcorper, mauris risus pulvinar ante, quis consequat mi sapien porttitor massa."
status: 'Live'
flavor: 'Deck'
---
# Objects: The Basics

---

### Goals

1. Lorem
2. Ipsum
3. Sic

---

### Roadmap

1. OO in C#
2. Fields
3. Properties
4. Constructors
5. Methods
6. Instantiation

---



## OO in C#

---

### OO Defined

* [Object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) combines data and behavior into a single unit called an object
* Objects maintain [state](https://en.wikipedia.org/wiki/State_(computer_science)) (fields) and expose [behavior](https://en.wikipedia.org/wiki/Behavior-driven_development) (methods)
* Facilitates code reuse, modularity, and separation of concerns

---

### Core OO Principles
1. [Encapsulation](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/encapsulation): Hide implementation details, expose controlled interfaces
1. [Inheritance](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/inheritance): Derive new types from existing ones
1. [Polymorphism](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/polymorphism): Objects can take different forms at runtime
1. [Abstraction](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/abstractions): Model complex systems using simplified representations

---

### OO in C#

* Key language constructs:
  - [`class`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class): Defines a reference type that encapsulates data and behavior
  - [`new`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/new-operator): Creates instances of types at runtime
* Strong type system with compile-time checking
* Built-in support for common OO patterns and practices
* [Properties](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties) provide controlled access to object state

---

### Example
```csharp
class Person{
  public string Name { get; set; }
  public int Age { get; set; }
}
Person p = new Person();
p.Name = "John";
p.Age = 30;
```

---

### Words of Caution
* OO was [dominant in the early 2000s](https://en.wikipedia.org/wiki/Object-oriented_programming#History)
* Pure OO systems can become:
  - Brittle through [tight coupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming))
  - Hard to test
  - [Difficult to parallelize](https://www.microsoft.com/en-us/research/publication/objects-have-failed-notes-for-a-debate/) safely
* Modern C# is [multi-paradigm](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/#object-oriented-and-component-oriented)


---


## Fields

---

### Overview

* [Fields](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/fields) are variables declared at the class level
* Also known as 'data members'
* Store the state of an object
* Best practices:
  - Keep fields [`private`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private)
  - Make them [`readonly`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly) when possible
* Common [naming convention](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions): camelCase with optional underscore prefix
---

### Example

```csharp
class Person{
  private int age;
  private string name;
  private string email;
}
```

---

### Access Modifiers

* Control the visibility and accessibility of types and members
* Available modifiers:
  - [`public`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public): Accessible from anywhere
  - [`private`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private): Accessible only within the containing type
  - [`protected`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected): Accessible within the type and derived types
  - [`internal`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal): Accessible within the same assembly
  - [`protected internal`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal): Accessible within the assembly or derived types
  - [`private protected`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected): Accessible within containing type or derived types in same assembly
* [Default accessibility](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers) is `private` for members, `internal` for types


---

### Fatherly Advice
* **Always** `private` for fields
* **Never** accept the default-- i.e. be explicit
* **>95%** of the time use `private` or `public` 

---

### Keyword: `readonly`
* [Readonly](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly) fields are initialized at runtime
* Can be initialized in constructor or with an initializer
* Cannot be changed after initialization
* Not enforced at runtime

---

### Example
* Follows the [explicit dependency principle](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/dependency-injection) 
* If data can't change it can't get borked up

```csharp
class PersonsController{
  private readonly IPersonRepository repository;

  public PersonsController(IPersonRepository repository){
    this.repository = repository;
  }
  // ...
}
```

---

### Keyword: `static`
* [Static](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static) fields are shared across all instances of a class
* Can be initialized with a static constructor
* Can be used to implement [design patterns](https://en.wikipedia.org/wiki/Design_Patterns) like [Singleton](https://en.wikipedia.org/wiki/Singleton_pattern)
* Often a bad idea!

---

### Example: `static` field
* Shared mutable state is a recipe for disaster
```csharp
class Person{
  public static int Count = 0;

  public Person(){
    Count++;
  }
}
```

---

### Keyword: `const`
* [Const](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/const) fields are compile-time constants
* Conceptually similar to `static readonly`
* Must be initialized at declaration with compile-time constant values
* Enforced at runtime via text substitution
* Similar to a macro in C

---

### Example: `const` field

```csharp
class Person{
  public const int MaxAge = 150;
}
```

---









## Properties

---

### Motivating Example (I)

* Classes should protect invariants
* BUT public fields let anyone create invalid state

```csharp title='Person.cs'
class Person{
  public int age;
}
// Elsewhere
var p = new Person();
p.age = -30;
```

---

### Motivating Example (II)

```csharp title="Person.cs"
class Person{
  private int age;
  // Getters and Setters are ok. 
  // But not ergonomic
  public int GetAge() => age;
  
  public void SetAge(int value){
    if(value <= 0 || value > 150){
      throw new ArgumentException("Bogus age");
    }
    this.age = value;
  }
}

// Elsewhere
var p = new Person();
p.SetAge(-30);
```

---

### What's a [Property](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/using-properties)?

> Properties combine aspects of both fields and methods. To the user of an object, a property appears to
> be a field; accessing the property requires the same syntax. To the implementer of a class, a property
> is one or two code blocks, representing a get accessor and/or a set or init accessor.

---

### Example, Old School I

````csharp
class Person{
  private int age;

  public int Age{
    get { return age;}
    set {this.age = value;} //Notice `value`
  }
}

// Elsewhere
var p = new Person();
p.SetAge(-30); // Still ok!

---

### Example, Old School II

```csharp
class Person{
  private int age;

  public int Age{
    get { return age;}
    set {
      if(value <= 0 || value > 150){
        throw new ArgumentException("Bogus age");
      }
      this.age = value;
    }
  }
}

// Elsewhere
var p = new Person();
p.SetAge(-30); // Throws!
````

---

### Example, [Auto-Implemented](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties)

```csharp
class Person{
  public int Age{
    get;
    set;
  }
}

```

---

### [Accessibility](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/restricting-accessor-accessibility)

```csharp
class Person{
  public int Age{
    get;
    private set;
  }
}

```

---

### Pros and Cons

* Pros
  - Allows changes without breaking binary compatibily
  - Easy to consume
* Cons
  - Obscures intention
  - Can't be passed as a variable
  - Encourages runtime validation instead of compile time


---




## Constructors

---

### Overview
* [Constructors](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors) are special methods used to initialize objects
* Initialize fields and perform setup tasks
* Can have parameters and optional parameters

---

### Example

```csharp
class Die{
  private int sides;
  private Random random;

  public Die(int sides, Random random){
    this.sides = sides;
    this.random = random;
  }

  public Die(int sides = 6):
    this(sides, new Random())
  {}

  public int Roll() => random.Next(1, sides + 1);
  
}
```

---





## Methods

---

### Overview
* [Methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods) are functions attached to objects (or types)
* Same access modifiers as fields
* Can have parameters, return values, and optional parameters
* Can be [virtual](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual) or [abstract](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract)
* One-liners can use expression body

---


### Example

```csharp
class Person{
  public string Name { get; set; }
  public int Age { get; set; }

  public void Greet(){
    Console.WriteLine($"Hello, my name is {Name} and I am {Age} years old.");
  }

  public int Add(int a, int b)
    => a + b;
}
```

---

### About Parameters

* Parameters are [type/name pairs](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods#method-parameters) separated by commas
* [Optional parameters](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments#optional-arguments) have default values: `void Method(int x = 10)`
* Pass-by-reference options ([`ref`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref)/[`out`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out-parameter-modifier)) exist but are rarely needed

---

### Example: Parameters

```csharp
class Person{
  public static void Greet(string name, int age = 0) =>
    Console.WriteLine($"Hello, my name is {name} and I am {age} years old.");
  
}
```

---

### Calling Methods

* Methods are called using the object/instance name, followed by a dot, method name, and parentheses
* [Named parameters](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments#named-arguments) improve readability: `Method(x: 10, y: 20)`
* Order doesn't matter when using named parameters
* Can mix positional and named parameters (positional must come first)

---


### Example: Calling Methods

```csharp

```

---




## Instantiation

---

### Overview
* [Instantiation](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers) is the process of creating an object from a class
* Can be done using the `new` keyword or object initializer syntax

---

### Example

```csharp
class Person{
  public string Name { get; set; }
  public int Age { get; set; }
}

var p = new Person();
```

---

### Object Initializer

```csharp
var p = new Person{
  Name = "John",
  Age = 30
};
```

---

### "new" is Glue

* Using `new` [couples](https://en.wikipedia.org/wiki/Tight_coupling) your code to specific implementations
* Better approach: [Program to interfaces](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/abstractions-abstract-types-and-interfaces)
* [Dependency Injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection):
  - Makes components more testable and modular
  - Implements the [Explicit Dependency Principle](https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#explicit-dependencies)
* More to come

---

### Keyword: `this`
* [`this`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this) refers to current object instance
* Required to resolve name conflicts (e.g., parameter vs field)
* Optional for accessing members
* Style choice in most cases
* Used in extension methods and indexers

---

### Example: `this`

```csharp
public class Person{
  private string name;
  private int age;

  public Person(string name, int age){
    this.name = name;
    this.age = age;
  }
}

```


